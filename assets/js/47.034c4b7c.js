(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{590:function(e,a,t){"use strict";t.r(a);var n=t(2),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一、css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、css"}},[e._v("#")]),e._v(" 一、CSS")]),e._v(" "),t("p",[t("strong",[e._v("1.说一下CSS的盒模型？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("在HTML页面中的所有元素都可以看成是一个盒子\n盒子的组成：\n   内容content、内边距padding、边框border、外边距margin\n盒模型的类型：\n   标准盒模型：margin + border + padding + content\n   IE盒模型：margin + content(border + padding)\n控制盒模型的模式：\n   box-sizing:content-box（默认值，标准盒模型）\n   border-box（IE盒模型）\n")])])]),t("p",[t("strong",[e._v("2.CSS选择器的优先级？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("CSS的特性：继承性、层叠性、优先级\n   优先级：写CSS样式的时候，会给同一个元素添加多个样式，此时谁的权重高就显示谁的样式\n   标签、类/伪类/属性、全局选择器、行内样式、id、!important\n   !important > 行内样式 > id > 类/伪类/属性 > 标签/伪元素 > 全局选择器\n")])])]),t("p",[t("strong",[e._v("3.隐藏元素的方法有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("display:none;\n   元素在页面上消失，不占据空间\nopacity:0;\n   设置了元素的不透明度为0，元素不可见，占据空间位置\nvisibility:hidden;\n   让元素消失，占据空间位置，一种不可见的状态\nposition:absolute;\n   通过绝对定位将元素移出可视区域（例如，屏幕之外），虽然元素仍然存在于页面布局中，但不可见\nclip-path:inset(100%);\n   将元素裁剪到完全不可见的区域\n")])])]),t("p",[t("strong",[e._v("4.px和rem的区别是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("px是像素，显示器上给我们呈现画面的像素，每个像素的大小是一样，绝对单位长度\nrem，相对单位，相对于html根节点的font-size的值，直接给html节点的font-size:62.5%;\n   1rem = 10px; （16px*62.5%=10px）\n")])])]),t("p",[t("strong",[e._v("5.重绘重排有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小\n重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器就会根据每个盒模型的特性进行绘制\n浏览器的渲染机制\n对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排\n对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算几何属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘\n")])])]),t("p",[t("strong",[e._v("6.让一个元素水平垂直居中的方式有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.定位+margin\n2.定位+transform\n3.flex布局\n4.grid布局\n5.table布局\n")])])]),t("p",[t("strong",[e._v("7.CSS的哪些属性哪些可以继承？哪些不可以继承？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("CSS的三大特性：继承、层叠、优先级\n子元素可以继承父类元素的样式\n1.字体的一些属性：font\n2.文本的一些属性：line-height\n3.元素的可见性：visibility:hidden\n4.表格布局的属性：border-spacing\n5.列表的属性：list-style\n6.页面样式属性：page\n7.声音的样式属性\n")])])]),t("p",[t("strong",[e._v("8.有没有用过预处理器？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("预处理语言增加了变量、函数、混入等强大的功能\nSASS  LESS\n")])])]),t("h2",{attrs:{id:"二、javasscipt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、javasscipt"}},[e._v("#")]),e._v(" 二、JavaSscipt")]),e._v(" "),t("p",[t("strong",[e._v("1.JS由哪三部分组成？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("ECMAScript：JS的核心内容，描述了语言的基础语法，比如var,for，数据类型（数组、字符串）\n文档对象模型（DOM）：DOM把整个HTML页面规划为元素构成的文档，将HTML文档视为一个树状结构\n浏览器对象模型（BOM）：对浏览器窗口进行访问和操作\n")])])]),t("p",[t("strong",[e._v("2.JS有哪些内置对象？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("String Boolean Number Array Object Function Math Date RegExp...\nMath\n\tabs() sqrt() max() min()\nDate\n\tnew Date() getYear() \nArray\nString\n\tconcat() length  slice() split()\n")])])]),t("p",[t("strong",[e._v("3.操作数组的方法有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("push() pop() sort() splice() unshift() shift() reverse() concat() join() map() filter() every() some() reduce() isArray() findIndex()\n哪些方法会改变原数组？\npush() pop() sort() splice() unshift() shift() reverse() fill()\n")])])]),t("p",[t("strong",[e._v("4.JS对数据类的检测方式有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("typeof()\ninstanceof()\nconstructor\nObject.prototype.toString.call()\n")])])]),t("p",[t("strong",[e._v("5.说一下闭包，闭包有什么特点？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("什么是闭包？函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包\n特点：可以重复利用变量，并且这个变量不会污染全局的一种机制；这个变量是一直保存在内存中，不会被垃圾回收机制回收\n缺点：闭包较多的时候，会消耗内存，导致页面的性能下降，在IE浏览器中才会导致内存泄漏\n使用场景：防抖，节流，函数嵌套函数避免全局污染的时候\n")])])]),t("p",[t("strong",[e._v("6.前端的内存泄漏怎么理解？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JS里已经分配内存地址的对象，但是由于长时间没有释放或者没办法清除，造成长期占用内存的现象，会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。\n垃圾回收机制\n因素：一些未声明直接赋值的变量；一些未清空的定时器；过度的闭包；一些引用元素没有被清除。\n")])])]),t("p",[t("strong",[e._v("7.事件委托是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("又叫事件代理，原理就是利用了事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上\n如果子元素阻止了事件冒泡，那么委托也就不成立\n阻止事件冒泡：event.stopPropagation()\naddEventListener('click',函数名，true/false) 默认是false（事件冒泡），true（事件捕获）\n好处：提高性能，减少事件的绑定，也就减少了内存的占用。\n")])])]),t("p",[t("strong",[e._v("8.基本数据类型和引用数据类型的区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("基本数据类型：String Number Boolean undefined null Symbol Bigint\n   基本数据类型保存在栈内存当中，保存的就是一个具体的值\n引用数据类型（复杂数据类型）：Object Function Array\n   保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址\n   假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变\n")])])]),t("p",[t("strong",[e._v("9.说一下原型链？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("原型就是一个普通对象，它是为构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象\n使用prototype可以把方法挂在原型上，内存只保存一份\n__proto__可以理解为指针，实例对象中的属性，指向了构造函数的原型（prototype）\n")])])]),t("p",[t("strong",[e._v("10.new操作符具体做了什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.先创建一个空对象\n2.把空对象和构造函数通过原型链进行链接\n3.把构造函数的this绑定到新的空对象身上\n4.根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型\n")])])]),t("p",[t("strong",[e._v("11.JS是如何实现继承的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.原型链继承\n2.借用构造函数继承\n3.组合式继承\n4.ES6的class类继承\n")])])]),t("p",[t("strong",[e._v("12.JS的设计原理是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JS引擎 运行上下文 调用栈 事件循环 回调\n")])])]),t("p",[t("strong",[e._v("13.JS中关于this指向的问题？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. 全局对象中的this指向\n   指向的是window\n2. 全局作用域或者普通函数中的this\n   指向全局window\n3. this永远指向最后调用它的那个对象\n   在不是箭头函数的情况下\n4. new关键词改变了this的指向\n5. apply,call,bind\n   可以改变this指向，不是箭头函数\n6. 箭头函数中的this\n   它的指向在定义的时候就已经确定了\n   箭头函数它没有this,看外层是否有函数，有就是外层函数的this，没有就是window\n7. 立即执行函数中的this\n   永远指向了window,立即执行函数的执行环境具有全局性，因此this指向window\n")])])]),t("p",[t("strong",[e._v("14.script标签里的async和defer有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("当没有async和defer这两个属性的时候，浏览器会立刻加载并执行指定的脚本\n有async加载和渲染后面元素的过程将和script的加载和执行并行进行（异步）\n有defer加载和渲染后面元素的过程将和script的加载并行进行（异步），但是它的执行事件要等所有元素解析完成之后才会执行\n")])])]),t("p",[t("strong",[e._v("15.setTimeout最小执行时间是多少？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("HTML5规定的内容：\nsetTimeout最小执行时间是4ms\nsetInterval最小执行时间是10ms\n")])])]),t("p",[t("strong",[e._v("16.ES6和ES5有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JS的组成：ECMAScript BOM  DOM\nES5:ECMAScript5,2009年ECMAScript的第五次修订，ECMAScript2009\nES6:ECMAScript6,2015年ECMAScript的第六次修订，ECMAScript2015，是JS的下一个版本标准\n")])])]),t("p",[t("strong",[e._v("17.ES6的新特性有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. 新增块级作用域（let,const）\n   不存在变量提升\n   存在暂时性死区的问题\n   块级作用域的内容\n   不能在同一个作用域内重复声明\n2. 新增了定义类的语法糖（class）\n3. 新增了一种基本数据类型（symbol）\n4. 新增了解构赋值\n   从数组或者对象中取值，然后给变量赋值\n5. 新增了函数参数的默认值\n6. 给数组新增了API\n7. 对象和数组新增了扩展运算符\n8. Promise\n   解决回调地狱的问题。\n   自身有all,reject,resolve,race方法\n   原型上有then,catch\n   把异步操作队列化\n   三种状态：pending初始状态,fulfilled操作成功,rejected操作失败\n   状态：pending -> fulfilled;pending -> rejected 一旦发生，状态就会凝固，不会再变\n   async  await\n   同步代码做异步的操作，两者必须搭配使用\n   async表明函数内有异步操作，调用函数会返回promise\n   await是组成async的表达式，结果是取决于它等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用\n   await后的promise如果是reject状态，那么整个async函数都会中断，后面的代码不执行\n9. 新增了模块化（import,export）\n10. 新增了set和map数据结构\n   set就是不重复\n   map的key的类型不受限制\n11. 新增了generator\n12. 新增了箭头函数\n   不能作为构造函数使用，不能用new\n   箭头函数就没有原型\n   箭头函数没有arguments\n   箭头函数不能用call,apply,bind去改变this的执行\n   this指向外层第一个函数的this\n")])])]),t("p",[t("strong",[e._v("18.call,aply,bind三者有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同\ncall方法传的是一个参数列表\napply传递的是一个数组\nbind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()()\ncall方法的性能要比apply好一些，所以call用的更多一点，因为apply比call的步骤多很多，apply中定义的参数格式（数组），使得被调用之后需要做更多的事\n")])])]),t("p",[t("strong",[e._v("19.用递归的时候有没有遇到什么问题？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("如果一个函数内可以调用函数本身，那么这个就是递归函数\n函数内部调用自己\n特别注意：写递归必须要有退出条件return\n")])])]),t("p",[t("strong",[e._v("20.如何实现一个深拷贝？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("深拷贝就是完全拷贝一份新的对象，会在堆内存中开辟新的空间，拷贝的对象被修改后，原对象不受影响\n主要针对的是引用数据类型\n1. 扩展运算符\n   缺点：只能实现第一层，当有多层时还是浅拷贝\n2. JSON.parse(JSON.stringify())\n   缺点：该方法并不会拷贝内部函数\n3. 利用递归函数实现\n")])])]),t("p",[t("strong",[e._v("21.说一下事件循环？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JS是一个单线程的脚本语言\n主线程 执行栈 任务队列  宏任务 微任务\n主线程先执行同步任务，然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务\n全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！\n")])])]),t("p",[t("strong",[e._v("22.ajax是什么？怎么实现的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("创建交互式网页应用的网页开发技术\n    在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容\n通过XmlHttpRequest对象向服务器发送异步请求，然后从服务器拿到数据，最后通过JS操作DOM更新页面\n1.创建XmlHttpRequest对象XHR\n2.通过XHR对象里的open()方法和服务器建立连接\n3.构建请求所需的数据，并通过XHR对象的send()发送给服务器\n4.通过XHR对象的onreadystate change事件监听服务器和你的通信状态\n5.接收并处理服务器响应的数据结果\n6.把处理的数据更新到HTML页面上\n")])])]),t("p",[t("strong",[e._v("23.get和post有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.get一般是获取数据，post一般是提交数据\n2.get参数会放在url上，所以安全性比较差，post是放在body中\n3.get请求刷新服务器或退回是没有影响的，post请求退回时会重新提交数据\n4.get请求时会被缓存,post请求不会被缓存\n5.get请求会被保存在浏览器历史记录中,post不会\n6.get请求只能进行url编码，post请求支持很多种\n")])])]),t("p",[t("strong",[e._v("24.promise的内部原理是什么？它的优缺点是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果\nPromise主要就是解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，\n就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也很差\n有三种状态：pending初始状态  fulfilled成功状态  rejected失败状态\n状态改变只会有两种情况，\n    pending -> fulfilled; pending -> rejected 一旦发生，状态就会凝固，不会再变\n首先就是我们无法取消promise，一旦创建它就会立即执行，不能中途取消\n如果不设置回调，promise内部抛出的错误就无法反馈到外面\n若当前处于pending状态时，无法得知目前在哪个阶段。\n原理：\n    构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一个是reject\n    promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数\n")])])]),t("p",[t("strong",[e._v("25.promise和async await的区别是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.都是处理异步请求的方式\n2.promise是ES6，async await 是ES7的语法\n3.async await是基于promise实现的，他和promise都是非阻塞性的\n优缺点：\n1.promise是返回对象我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await 是通过tra catch进行捕获异常\n2.async await最大的优点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作\npromise.then()的方式返回，会出现请求还没返回，就执行了后面的操作\n")])])]),t("p",[t("strong",[e._v("26.浏览器的存储方式有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.cookies\n    H5标准前的本地存储方式\n    兼容性好，请求头自带cookie\n    存储量小，资源浪费，使用麻烦（封装）\n2.localstorage\n    H5加入的以键值对为标准的方式\n    操作方便，永久存储，兼容性较好\n    保存值的类型被限定，浏览器在隐私模式下不可读取，不能被爬虫\n3.sessionstorage\n    当前页面关闭后就会立刻清理，会话级别的存储方式\n4.indexedDB\n    H5标准的存储方式，他是以键值对进行存储，可以快速读取，适合WEB场景\n")])])]),t("p",[t("strong",[e._v("27.token存在sessionstorage还是loaclstorage？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串\n1.存loaclstorage里，后期每次请求接口都需要把它当作一个字段传给后台\n2.存cookie中，会自动发送，缺点就是不能跨域\n如果存在localstorage中，容易被XSS攻击，但是如果做好了对应的措施，那么是利大于弊\n如果存在cookie中会有CSRF攻击\n")])])]),t("p",[t("strong",[e._v("28.token的登录流程？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.客户端用账号密码请求登录\n2.服务端收到请求后，需要去验证账号密码\n3.验证成功之后，服务端会签发一个token，把这个token发送给客户端\n4.客户端收到token后保存起来，可以放在cookie也可以是localstorage\n5.客户端每次向服务端发送请求资源的时候，都需要携带这个token\n6.服务端收到请求，接着去验证客户端里的token，验证成功才会返回客户端请求的数据\n")])])]),t("p",[t("strong",[e._v("29.页面渲染的过程是怎样的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("DNS解析\n建立TCP连接\n发送HTTP请求\n服务器处理请求\n渲染页面\n    浏览器会获取HTML和CSS的资源，然后把HTML解析成DOM树\n    再把CSS解析成CSSOM\n    把DOM和CSSOM合并为渲染树\n    布局\n    把渲染树的每个节点渲染到屏幕上（绘制）\n断开TCP连接\n")])])]),t("p",[t("strong",[e._v("30.DOM树和渲染树有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("DOM树是和HTML标签一一对应的，包括head和隐藏元素\n渲染树是不包含head和隐藏元素\n")])])]),t("p",[t("strong",[e._v("31.精灵图和base64的区别是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面可以减少请求，提高加载速度\nbase64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串\nbase64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载\n")])])]),t("p",[t("strong",[e._v("32.svg格式了解多少？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('基于XML语法格式的图像格式，可缩放矢量图，其他图像是基于像素的，SVG是属于对图像形状的描述，本质是文本文件，体积小，并且不管放大多少倍都不会失真\n1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作\n<svg></svg>\n2.SVG可作为文件被引入\n<img src="pic.svg" />\n3.SVG可以转为base64引入页面\n')])])]),t("p",[t("strong",[e._v("33.了解过JWT吗？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输\n信息传输、授权\nJWT的认证流程\n1.前端把账号密码发送给后端的接口\n2.后端核对账号密码成功后，把用户id等其他信息作为JWT负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）\n3.前端每次请求时都会把JWT放在HTTP请求头的Authorization字段内\n4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）\n5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果\n简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持\n")])])]),t("p",[t("strong",[e._v("34.npm的底层环境是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("node package manager,node的包管理和分发工具，已经成为分发node模块的标准，是JS的运行环境\nnpm的组成：网站、注册表、命令行工具\n")])])]),t("p",[t("strong",[e._v("35.HTTP协议规定的协议头和请求头有什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.请求头信息：\nAccept:浏览器告诉服务器所支持的数据类型\nHost:浏览器告诉服务器我想访问服务器的哪台主机\nReferer:浏览器告诉服务器我是从哪里来的（防盗链）\nUser-Agent:浏览器类型、版本信息\nDate:浏览器告诉服务器我是什么时候访问的\nConnection:连接方式\nCookie\nX-Request-With:请求方式\n2.响应头信息：\nLocation:这个就是告诉浏览器你要去找谁\nServer:告诉浏览器服务器的类型\nContent-Type:告诉浏览器返回的数据类型\nRefresh:控制浏览器的定时刷新\n")])])]),t("p",[t("strong",[e._v("36.说一下浏览器的缓存策略？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("强缓存（本地缓存）、协商缓存（弱缓存）\n强缓：不发起请求，直接使用缓存里的内容，浏览器把JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能\n协缓：即使本地有缓存，仍然会向服务器发送请求，通过服务器验证缓存是否可用，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容\n强缓存的触发：\n    HTTP1.0:Expires\n    HTTP1.1:Cache-Control响应标头\n协商缓存触发：\n    HTTP1.0:请求头：if-modified-since 响应头：last-modified\n    HTTP1.1:请求头：if-none-match 响应头：Etag\n")])])]),t("p",[t("strong",[e._v("37.说一下什么是“同源策略”？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("http:// www.  aaa.com:8080/index/vue.js\n协议    子域名   主域名  端口号       资源\n同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击\n主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，会产生跨域\n三个允许跨域加载资源的标签：img  link  script\n跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！\n解决跨域的方式：\nJSONP\nCORS\nwebsocket\n反向代理\n")])])]),t("p",[t("strong",[e._v("38.防抖和节流是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("都是应对页面中频繁触发事件的优化方案\n防抖:避免事件重复触发，只执行最后一次\n使用场景:1.频繁和服务端交互 2.输入框的自动保存事件\n节流:把频繁触发的事件减少,每隔一段时间执行，只执行第一次\n使用场景:scroll事件\n")])])]),t("p",[t("strong",[e._v("39.解释一下什么是json？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("JSON是一种纯字符串形式的数据，它本身不提供任何方法，适合在网络中进行传输\nJSON数据存储在.json文件中，也可以把JSON数据以字符串的形式保存在数据库、Cookie中\nJS提供了JSON.parse() JSON.stringify()\n什么时候使用json：定义接口；序列化；生成token；配置文件package.json\n")])])]),t("p",[t("strong",[e._v("40.当数据没有请求过来的时候，该怎么做？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("可以在渲染数据的地方给一些默认的值\nif判断语句，有数据则显示，没数据则隐藏\n")])])]),t("p",[t("strong",[e._v("41.有没有做过无感登录？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.在响应器中拦截，判断token返回过期后，调用刷新token的接口\n2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口\n3.写定时器，定时刷新token接口\n第一种方法的流程：\n    1.登录成功后保存token 和 refresh_token\n    2.在响应拦截器中对401状态码引入刷新token的api方法调用\n    3.替换保存本地新的token\n    4.把错误对象里的token替换\n    5.再次发送未完成的请求\n    6.如果refresh_token过期了，判断是否过期，过期了就清楚所有token重新登录\n")])])]),t("p",[t("strong",[e._v("42.大文件上传是怎么做的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("分片上传：\n    1.把需要上传的文件按照一定的规则，分割成相同大小的数据块\n    2.初始化一个分片上传任务，返回本次分片上传的唯一标识（md5加密）\n    3.按照一定的规则把各个数据块上传\n    4.发送完成后，服务端会判断数据上传的完整性，如果完整，那么就会把数据库合并成原始文件\n断点续传：\n    服务端返回，从哪里开始，浏览器自己处理\n速度优化：\n\tWeb Worker多线程\n")])])]),t("h2",{attrs:{id:"三、html5css3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、html5css3"}},[e._v("#")]),e._v(" 三、HTML5CSS3")]),e._v(" "),t("p",[t("strong",[e._v("1.语义化的理解？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("在写HTML页面结构时所用的标签有意义\n   头部用header  主体用main  底部用footer...\n怎么判断页面是否语义化了？\n   把CSS去掉，如果能够清晰的看出来页面结构，显示内容较为正常\n为什么要选择语义化？\n1.让HTML结构更加清晰明了\n2.方便团队协作，利于开发\n3.有利于爬虫和SEO\n4.能够让浏览器更好的去解析代码\n5.给用户带来良好的体验\n")])])]),t("p",[t("strong",[e._v("2.H5C3有哪些新特性？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("H5的新特性：\n1.语义化的标签\n2.新增音频视频\n3.画布canvas\n4.数据存储localstorage sessionstorage\n5.增加了表单控件 email url search...\n6.拖拽释放API\nCSS3的新特性：\n1.新增选择器：属性选择器、伪类选择器、伪元素选择器\n2.增加了媒体查询\n3.文字阴影\n4.边框\n5.盒子模型box-sizing\n6.渐变\n7.过渡\n8.自定义动画\n9.背景的属性\n10.2D和3D\n")])])]),t("p",[t("strong",[e._v("3.rem是如何做适配的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("rem是相对长度，相对于根元素（html）的font-size属性来计算大小，通常来做移动端的适配\nrem是根据根元素font-size计算值的倍数\n比如html上的font-size:16px，给div设置宽为1.2rem,1.2rem = 16px*1.2 = 19.2px.\n")])])]),t("p",[t("strong",[e._v("4.解决了哪些移动端的兼容问题？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.当设置样式overflow:scroll/auto时，IOS上的滑动会卡顿\n\t-webkit-overflow-scrolling:touch;\n2.在安卓环境下placeholder文字设置行高时会偏上\n\tinput有placeholder属性的时候不要设置行高\n3.移动端字体小于12px时异常显示\n\t应该先将页面的根字体大小放大一倍，然后再用transform: scale(0.5)进行缩小\n4.IOS下input按钮设置了disabled属性为true显示异常\n    input[typy=button]{\n        opcity:1\n    }\n5.安卓手机下取消语音输入按钮\n    input::-webkit-input-speech-button{\n        display:none\n    }\n6.IOS下取消input输入框在输入英文首字母默认大写\n    <input autocapitalize='off' autocorrect='off'/>\n7.禁用IOS和安卓用户选中文字\n    添加全局CSS样式：-webkit-user-select:none\n8.禁止IOS弹出各种窗口\n    -webkit-touch-callout:none\n9.禁止IOS识别长串数字为电话\n    添加meta属性 <meta content='telephone=no' name='format-detection'>\n")])])]),t("h2",{attrs:{id:"四、vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、vue"}},[e._v("#")]),e._v(" 四、Vue")]),e._v(" "),t("p",[t("strong",[e._v("1.v-if和v-show的区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("都可以控制元素的显示和隐藏\n1.v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除\n2.v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换\n3.v-if才是真正的条件渲染；v-show从false变成true的时候不会触发组件的声明周期，v-if会触发声明周期\n4.v-if的切换效率比较低  v-show的效率比较高\n")])])]),t("p",[t("strong",[e._v("2.如何理解MVVM的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("是Model-View-ViewModel的缩写。前端开发的架构模式\nM：模型，对应的就是data的数据\nV：视图，用户界面，DOM\nVM：视图模型：Vue的实例对象，连接View和Model的桥梁\n核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定\nViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要人为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为它是由MVVM统一管理\n")])])]),t("p",[t("strong",[e._v("3.v-for中的key值的作用是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("key属性是DOM元素的唯一标识\n作用：\n1.提高虚拟DOM的更新\n2.若不设置key，可能会触发一些bug\n3.为了触发过渡效果\n")])])]),t("p",[t("strong",[e._v("4.说一下你对vue生命周期的理解？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("组件从创建到销毁的过程就是它的生命周期\n创建\n    beforeCreate\n    在这个阶段属性和方法都不能使用\n    created\n    这里是实例创建完成之后，在这里完成了数据监测，可以使用数据，修改数据，不会触发updated，也不会更新视图\n挂载\n    beforeMount\n    完成了模板的编译，虚拟DOM也完成创建，即将渲染，修改数据，不会触发updated\n    Mounted\n    把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点\n更新\n    beforeUpdate\n    组件数据更新之前使用，数据是新的，页面上的数据是旧的，组件即将更新，准备渲染，可以改数据\n    updated\n    render重新做了渲染，这时数据和页面都是新的，避免在此更新数据\n销毁\n    beforeDestroy\n    实例销毁前，在这里实例还可以用，可以清除定时器等等\n    destroyed\n    组件已经被销毁了，全部都销毁\n使用了keep-alive时多出两个周期：\n    activated\n    组件激活时\n    deactivated\n    组件被销毁时\n")])])]),t("p",[t("strong",[e._v("5.在created和mounted去请求数据，有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("created：在渲染前调用，通常先初始化属性，然后做渲染\nmounted：在模板渲染完成后，一般都是初始化页面后，在对元素节点进行操作，在这里请求数据可能会出现闪屏的问题，created里不会\n一般用created比较多\n如果请求的数据不会影响DOM，那么使用created\n如果请求的数据会影响DOM，可以放在mounted（不然无法操作DOM）\n")])])]),t("p",[t("strong",[e._v("6.vue中的修饰符有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.事件修饰符\n.stop       阻止冒泡\n.prevent    阻止默认行为\n.capture    内部元素触发的事件先在此处理，先处理捕获，再处理冒泡\n.self       只有在event.target是当前元素时触发\n.once       事件只会触发一次\n.passive    立即触发默认行为，主要用于提升滚动性能\n.native     把当前元素作为原生标签看待，以click事件为例，如果组件内部已经有$emit('click')，那就不需要.native，Vue直接监听 click事件就行，否则，如果没有$emit('click')，也没有.native，click事件就无法响应\n2.按键修饰符\n.keyup      键盘抬起\n.keydown    键盘按下\n3.系统修饰符\n.ctrl\n.alt\n.meta\n4.鼠标修饰符\n.left       鼠标左键\n.right      鼠标右键\n.middle     鼠标中键\n5.表单修饰符\n.lazy       等输入完之后再显示\n.trim       删除内容前后的空格\n.number     输入是数字或转为数字\n")])])]),t("p",[t("strong",[e._v("7.elementui是怎么做表单验证的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.在表单中加rules属性，然后再data里写校验规则\n2.直接在行内添加规则\n3.自定义函数校验（应对复杂逻辑）\n")])])]),t("p",[t("strong",[e._v("8.vue如何进行组件通信？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.父传子\nprops\n\t父组件使用自定义属性，然后子组件使用props\n$ref\n\t父组件通过$refs调用子组件的方法，给子组件传递信息\n2.子传父\n$emit\n\t子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数（子组件$emit，父组件@事件名来监听）\n3.兄弟传值\nnew一个新的vue实例，用$emit（发送）和$on（监听）来对数据进行传输，Bus事件总线\n4.vuex/pinia传值\n")])])]),t("p",[t("strong",[e._v("9.keep-alive是什么？怎么使用？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue的一个内置组件，包裹组件的时候，会缓存不活跃的组件实例，并不是销毁他们\n作用：把组件切换的状态保存在内存里，防止重复渲染DOM节点，减少加载时间和性能消耗，提高用户体验\n")])])]),t("p",[t("strong",[e._v("10.axios是怎么做封装的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("下载 创建实例 封装请求响应拦截器 导出 在接口中调用\n")])])]),t("p",[t("strong",[e._v("11.vue路由是怎么传参的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.params传参（不显示参数）\n    this.$router.push({name:'index',params:{id:item.id}})\n    this.$route.params获取\n2.params传参（显示参数）\n    this.$router.push({name:'/index/${item.id}'})\n\t路由配置 { path:'/index/:id' }\n\tthis.$route.params获取\n3.query传参（显示参数，可以解决页面刷新参数丢失的问题）\n    this.$router.push({\n        name:'index',\n        query:{id:item.id}\n    })\n    this.$route.query获取\n")])])]),t("p",[t("strong",[e._v("12.vue路由的hash模式和history模式有什么区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.hash的路由地址上有#号，history模式没有\n2.在做回车刷新的时候，hash模式会加载对应页面，history会报错404（如果服务器没有额外进行配置）\n3.hash模式支持低版本浏览器，兼容性更好，history不支持，因为是H5新增的API\n4.hash不会重新加载页面，单页面应用必备\n5.history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求\n6.history需要后台配置\n")])])]),t("p",[t("strong",[e._v("13.路由拦截是怎么实现的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("路由拦截 axios拦截\n需要在路由配置中添加一个字段，它是用于判断路由是否需要拦截\n{\n    name:'index',\n    path:'/index',\n    component:Index,\n    meta:{\n        requireAuth:true\n    }\n}\nrouter.beforeEach((to,from,next) => {\n    if(to.meta.requireAuth){\n        if( store.satte.token ){\n       \t\tnext()\n        }else{\n\n        }\n    }\n})\n路由拦截主要是通过全局守卫（beforeEach和afterEach）、路由独享守卫（beforeEnter）和组件内守卫（beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave）来实现\n")])])]),t("p",[t("strong",[e._v("14.说一下vue的动态路由？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("要在路由配置里设置meta属性，扩展权限相关的字段，在路由导航守卫里通过判断这个权限标识，实现路由的动态增加和跳转\n根据用户登录的账号，返回用户角色\n前端再根据角色，跟路由表的meta.role进行匹配\n把匹配搭配的路由形成可访问的路由\n")])])]),t("p",[t("strong",[e._v("15.如何解决刷新后二次加载路由？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.window.location.reload()\n2.matcher\n    const router = createRouter()\n    export function resetRouter(){\n        const newRouter = creatRouter()\n        router.matcher = newRouter.matcher\n    }\n")])])]),t("p",[t("strong",[e._v("16.vuex刷新数据会丢失吗？怎么解决？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vuex肯定会重新获取数据，页面也会丢失数据（Vuex的状态是存储在内存中的，刷新会重置）\n1.把数据直接保存在浏览器缓存里（cookie  localstorage  sessionstorage）\n2.页面刷新的时候，再次请求数据，达到可以动态更新的方法\n    监听浏览器的刷新事件，在刷新前把数据保存到sessionstorage里，刷新后请求数据，请求到了用vuex，如果没有那就用sessionstorage里的数据\n3.使用vuex-persistedstate插件，其本质也是自动将Vuex状态同步到localStorage或sessionStorage，避免刷新丢失\n")])])]),t("p",[t("strong",[e._v("17.computed和watch的区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.computed是计算属性，watch是监听，监听的是data中数据的变化\n2.computed是支持缓存，依赖的属性值发生变化，计算属性才会重新计算，否则用缓存；watch不支持缓存\n3.computed不支持异步，watch是可以异步操作\n4.computed是第一次加载就监听，watch是不监听\n5.computed函数中必须有return  watch不用\n")])])]),t("p",[t("strong",[e._v("18.vuex在什么场景会去使用？属性有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("state       存储变量\ngetters     state的计算属性\nmutations   提交更新数据的方法\nactions     和mutations差不多，他是提交mutations来修改数据，可以包括异步操作\nmodules     模块化vuex\n使用场景：\n    用户的个人信息、购物车模块、订单模块\n")])])]),t("p",[t("strong",[e._v("19.vue的双向数据绑定原理是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('通过数据劫持和发布订阅者模式来实现，同时利用Object.defineProperty()劫持各个属性的set和get，\n在数据发生改变的时候发布消息给订阅者，触发对应的监听回调渲染视图，也就是说数据和视图是同步的，数据发生改变，视图跟着发生改变，视图改变，数据也会发生改变。\n第一步：需要observer的数据对象进行递归遍历，包括子属性对象的属性，都加上set和get\n第二步：compile模板解析指令，把模板中的变量替换成数据，然后初始化渲染视图，同时把每个指令对应的节点绑定上更新函数，添加订阅者，如果数据变化，收到通知，更新视图\n第三步：Watcher订阅者是Observer和Compile之间的通信桥梁，作用：\n       1.在自身实例化的时候往订阅器内添加自己\n       2.自身要有一个update()方法\n       3.等待属性变动时，调用自身的update方法，触发compile这种的回调\n第四步：MVVM作为数据绑定的入口，整合了observer、compile和watcher三者，通过observer来监听自己的数据变化，通过compile解析模板指令，最后利用watcher把observer和compile联系起来，最终达到数据更新视图更新，视图更新数据更新的效果\n各种类与函数的作用：\nVue类负责初始化数据和界面。\nObserver函数监控数据的变化。\nComplie函数把数据展示到页面上。\nfragment_compile函数替换模板中的变量，处理输入框。\nDependency类管理所有观察者的通知。\nWatcher类观察属性变化，并触发更新。\n数据双向绑定的原理是利用object.defineProperty函数劫持默认的get和set。在new一个vue的时候遍历el:"#app"的HTML，将里面的{{ }}里的值替换成vue中data对应的值，因为替换需要读取，然而get函数已经被我们劫持了，我就能知道这个HTML标签的{{}}和data的值已经对应了，我把他标记成订阅者并存入发布器里面。然后在data的值变动的时候，因为我们劫持了set方法，他会遍历发布器里面的订阅者，然后一一对应修改订阅者HTML的{{}}。\n')])])]),t("p",[t("strong",[e._v("20.了解diff算法和虚拟DOM吗？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("虚拟DOM，描述元素和元素之间的关系，创建一个JS对象\n如果组件内有响应的数据，数据发生改变的时候，render函数会生成一个新的虚拟DOM，这个新的虚拟DOM会和旧的虚拟DOM进行比对，找到需要修改的虚拟DOM内容，然后去对应的真实DOM中修改\ndiff算法就是虚拟DOM的比对时用的，返回一个patch对象，这个对象的作用就是存储两个节点不同的地方，最后用patch里记录的信息进行更新真实DOM\n步骤：\n    1.JS对象表示真实的DOM结构，要生成一个虚拟DOM，再用虚拟DOM构建一个真实DOM树，渲染到页面\n    2.状态改变生成新的虚拟DOM，跟旧的虚拟DOM进行比对，这个比对的过程就是DIFF算法，利用patch记录差异\n    3.把记录的差异用在第一个虚拟DOM生成的真实DOM上，视图就更新了\n")])])]),t("p",[t("strong",[e._v("21.vue和jquery的区别是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.原理不同\n    vue就是数据绑定；jq是先获取dom再处理\n2.着重点不同\n    vue是数据驱动，jq是着重于页面\n3.操作不同\n4.未来发展不同\n5.vue是框架，jq只是个js库\n")])])]),t("p",[t("strong",[e._v("22.vuex的响应式处理？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vuex是vue的状态管理工具\nvue中可以直接触发methods中的方法，vuex是不可以的。为了处理异步，当触发事件的时候，会通过dispatch来访问actions中的方法，actions中的commit会触发mutations中的方法从而修改state里的值，通过getter把数据更新到视图\nVue.use(vuex)，调用install方法，通过applyMixin(vue)在任意组件内执行this.$store就可以访问到store对象\nvuex的state是响应式的，借助的就是vue的data，把state存到vue实例组件的data中\n")])])]),t("p",[t("strong",[e._v("23.vue中遍历全局的方法有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.普通遍历，对象.forEach()\n    arr.forEach(function(item,index,arr){\n        console.log(item,index)\n    })\n2.对元素统一操作  对象.map()\n    let newarr = arr.map(function(item){\n        return item+1\n    })\n3.查找符合条件的元素 对象.filter()\n    let newarr = arr.filter(function(item){\n        if(item > 2){\n            return false\n        }else{\n            return true\n        }\n    })\n4.查询符合条件的元素，返回索引对象.findindex()\n    arr.finindex(function(item){\n        if(item>1){\n            return true\n        }else{\n            return false\n        }\n    })\n对象.every()  遇到不符合的对象会停止\n对象.some()  找到符合条件的元素就停止\n")])])]),t("p",[t("strong",[e._v("24.如何搭建脚手架？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("下载：node  cnpm  webpack vue-cli\n创建项目：\n    1.找到对应的文件，然后利用node指令创建（cmd）\n    2.vue init webpack xxxx\n    3.回车项目描述\n    4.作者回车\n    5.选择vue build\n    6.回车\n    7.输入n\n    8.不按照yarn\n    9.输入npm run dev\n")])])]),t("p",[t("strong",[e._v("25.如何封装一个组件？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.使用Vue.extend()创建一个组件\n2.使用Vue.components()方法注册组件\n3.如果子组件需要数据，可以在props中接收定义\n4.子组件修改好数据，要把数据传递给父组件，可以用emit()方法\n原则：\n    把功能拆开\n    尽量让组件原子化，一个组件做一件事情\n    容器组件管数据，展示组件管视图\n")])])]),t("p",[t("strong",[e._v("26.封装一个可复用的组件，需要满足什么条件？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.低耦合，组件之间的依赖越小越好\n2.最好从父级传入信息，不要在公共组件中请求数据\n3.传入的数据要进行校验\n4.处理事件的方法写在父组件中\n")])])]),t("p",[t("strong",[e._v("27.vue的过滤器怎么使用？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vue2的特性，用来对文本进行格式化处理，vue3中已弃用\n使用它的两个地方，一个是插值表达式，一个是v-bind\n分类：\n1.全局过滤器\n\t<div>{{33 | add}}</div>\n    Vue.filter('add',function(v){\n        return v < 10 ? '0' + v : v\n    })\n2.本地过滤器\n    和methods同级\n    filter:{\n        add:function(v){\n            return v < 10 ? '0' + v : v\n        }\n    }\n")])])]),t("p",[t("strong",[e._v("28.vue中如何做强制刷新？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.location.reload()\n2.this.$router.go(0)\n3.改变组件的key值\n4.$forceUpdate()\n")])])]),t("p",[t("strong",[e._v("29.vue3和vue2有哪些区别？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.双向数据绑定的原理不同\n2.是否支持碎片\n3.API不同，vue2选项式API，vue3组合式API\n4.定义数据变量方法不同\n5.生命周期的不同\n6.传值不同\n7.指令和插槽不同\n8.main.js不同\n")])])]),t("p",[t("strong",[e._v("30.vue的性能优化怎么做？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.编码优化\n    不要把所有数据都放在data中\n    v-for时给每个元素绑定事件用事件代理\n    keep-alive缓存组件\n    尽可能拆分组件，提高复用性、维护性\n    key值要保证唯一\n    合理使用路由懒加载，异步组件\n    数据持久化存储的使用尽量用防抖、节流优化\n2.加载优化\n    按需加载\n    内容懒加载\n    图片懒加载\n3.用户体验\n    骨架屏\n4.SEO优化\n    预渲染\n    服务端渲染ssr\n5.打包优化\n    CDN形式加载第三方模块\n    多线程打包\n    抽离公共文件\n6.缓存和压缩\n    客户端缓存、服务端缓存\n    服务端Gzip压缩\n")])])]),t("p",[t("strong",[e._v("31.首屏优化该如何去做？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.使用路由懒加载\n2.非首屏组件使用异步组件\n3.首屏不重要的组件延迟加载\n4.静态资源放在CDN上\n5.减少首屏上JS、CSS等资源文件的大小\n6.使用服务端渲染\n7.尽量减少DOM的数量和层级\n8.使用精灵图请求\n9.做一些loading\n10.开启Gzip压缩\n11.图片懒加载\n")])])]),t("p",[t("strong",[e._v("32.vue3的性能为什么比vue2好？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.Diff算法优化：Vue3采用了更高效的Diff算法来比较虚拟DOM之间的差异，并只更新有差异的部分，而不是重新渲染整个组件。这种优化可以大大减少不必要的DOM操作，提高渲染性能\n2.静态提升：Vue3采用了静态提升技术，将静态内容预先生成成静态资源，在浏览器端直接使用这些静态资源，避免了解析和编译，进一步提高了渲染性能\n3.事件侦听缓存：Vue3使用了事件侦听缓存，将侦听器缓存到指令实例中，减少了创建和销毁侦听器的次数，从而提高了性能\n")])])]),t("p",[t("strong",[e._v("33.vue3为什么使用proxy？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.proxy可以代理整个对象，defineproperty只代理对象上的某个属性，如果存在嵌套对象则需要递归，而proxy可以直接代理整个对象\n2.proxy对代理对象的监听方法更加丰富，如对象新增属性、函数操作的调用\n3.proxy代理对象会生成新的对象，不会修改被代理对象本身\n4.proxy不兼容ie浏览器\n")])])]),t("p",[t("strong",[e._v("34.说一下你对组件的理解？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("可以重复使用的vue实例，独一无二的组件名称\n可以抽离单独的公共模块\n提高代码的复用率\n组件：将单个页面划分为多个独立的可重用的功能，提高代码的可维护性和可重用性\n")])])]),t("p",[t("strong",[e._v("35.你是如何规划项目文件的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public\n    图标、index.html、img\nsrc\n    api\n    assets\n    components\n        按分类再次划分子目录\n    plugins\n    router\n    static\n    styles\n    utils\n    views\nApp.vue\nmain.js\npackage.json\nvue.config.js\n")])])]),t("p",[t("strong",[e._v("36.是否使用过nuxt.js？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("是基于vue的应用框架，关注的是渲染，可以开发服务端渲染应用的配置\nSSR：服务端渲染\n    好处：\n        SSR生成的是有内容的HTML页面，有利于搜索引擎的搜索\n        优化了首屏加载时间，直接传渲染完成的HTML页面，不用客户端挂载等等\nSEO：优化搜索引擎，简单来说就是让网站在搜索后的排名更靠前\n为什么要用nuxt.js：SPA的应用不利于搜索引擎SEO的操作\n")])])]),t("p",[t("strong",[e._v("37.SEO如何优化？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.SSR\n2.预渲染 prerender-spa-plugin，事先渲染一些东西到页面中，只能适当提升SEO的效果\n只要用Vue做的项目都是SPA，是SPA就会存在SEO问题\n")])])]),t("h2",{attrs:{id:"五、echarts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、echarts"}},[e._v("#")]),e._v(" 五、Echarts")]),e._v(" "),t("p",[t("strong",[e._v("1.echarts有用过吗？常用的组件有哪些？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("title标题组件 show  text  link\ntoolbox工具栏 导出图片 数据视图 切换 缩放 show orient feature\ntooltip trigger 触发类型\nmarkPoint标注点\nmarkLine图标的标线\n")])])]),t("h2",{attrs:{id:"六、uni-app"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、uni-app"}},[e._v("#")]),e._v(" 六、Uni-APP")]),e._v(" "),t("p",[t("strong",[e._v("1.uni-app有没有做过分包？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("优化小程序的下载和启动速度\n小程序启动默认下载主包并启动页面，当用户进入分包时，才会下载对应的分包，下载完进行展示\n如何设置：在manifest里面设置开启分包，然后再page.json里面设置分包规则、路由等\n")])])]),t("h2",{attrs:{id:"七、weabpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、weabpack"}},[e._v("#")]),e._v(" 七、Weabpack")]),e._v(" "),t("p",[t("strong",[e._v("1.webpack打包和不打包的区别？（是否使用webpack进行打包）")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.运行效率\n2.对技术的支持，如针对es6语法等用webpack打包后可以解析成浏览器能够识别的语言\n")])])]),t("p",[t("strong",[e._v("2.webpack是怎么打包的，babel是做什么的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("怎么打包：\n    webpack会把js css image看作一个模块，用import/require引入\n    找到入口文件，通过入口文件找到关联的依赖文件，把他们打包到一起\n    把bundle文件，拆分成多个小的文件，异步按需加载所需要的文件\n    如果一个被多个文件引用，打包时只会生成一个文件\n    如果引用的文件没有调用，不会打包，如果引入的变量和方法没有调用也不会打包\n    对于多个入口文件，加入引入了相同的代码，可以用插件把他抽离到公共文件中 \nbabel是做什么的：\n\t把高级语法解析成浏览器支持的低级语法\n")])])]),t("h2",{attrs:{id:"八、git"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、git"}},[e._v("#")]),e._v(" 八、Git")]),e._v(" "),t("p",[t("strong",[e._v("1.git如何合并、拉取代码？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("拉取代码 git pull '仓库地址'\n查看状态 git status\n提交到本地缓存区  git add .\n提交本地仓库 git commit -m '修改描述'\n提交到远程仓库 git push '仓库地址' master\n创建分支 git branch -b xxx\n合并分支 git merge '合并分支的名字'\n")])])]),t("p",[t("strong",[e._v("2.git如何解决冲突问题？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.两个分支中修改了同一个文件\n2.两个分支中修改了同一个文件的名字\n1.解决：当前分支上，直接修改代码  add  commit\n2.解决：在本地当前分支上，修改冲突代码 add commit push\n")])])]),t("h2",{attrs:{id:"九、hr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九、hr"}},[e._v("#")]),e._v(" 九、HR")]),e._v(" "),t("p",[t("strong",[e._v("1.你的离职原因是什么？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("疫情 社保 薪资问题 个人发展 技术提升 家庭因素\n")])])]),t("p",[t("strong",[e._v("2.工作到现在，项目中遇到最难的问题是什么？怎么解决的？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.不要回答，没有问题\n2.不要说一些常见的简单的问题，比如：数据请求不过来、渲染页面时出现了问题、跳转路由不会...\n首先应该时自行去查找资料寻求解决办法，然后再去请教同事或者组长\n")])])]),t("p",[t("strong",[e._v("3.你的优势在哪里？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.尽量不要暴露自己的缺点\n2.不要过度美化自己\n")])])]),t("p",[t("strong",[e._v("4.如何协同工作？")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1.开发前会开个会议，最后形成一个开发文档\n2.利用工具保证项目的正常进度，规范化\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);