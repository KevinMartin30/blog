(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{595:function(n,t,e){"use strict";e.r(t);var a=e(2),s=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[e("strong",[n._v("题目来源于 CodeTop 前端高频算法题，记录解题思路与代码")])]),n._v(" "),e("h2",{attrs:{id:"_3-无重复字符的最长子串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-无重复字符的最长子串"}},[n._v("#")]),n._v(" 3.无重复字符的最长子串")]),n._v(" "),e("p",[n._v("给定一个字符串 "),e("code",[n._v("s")]),n._v(" ，请你找出其中不含有重复字符的 "),e("strong",[n._v("最长子串")]),n._v("的长度。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入: s = "abcabcbb"\n输出: 3\n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n')])])]),e("p",[e("strong",[n._v("示例 2:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入: s = "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n')])])]),e("p",[e("strong",[n._v("示例 3:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入: s = "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("0 <= s.length <= 5 * 10^4")])]),n._v(" "),e("li",[e("code",[n._v("s")]),n._v(" 由英文字母、数字、符号和空格组成")])]),n._v(" "),e("p",[e("strong",[n._v("1.暴力解法")])]),n._v(" "),e("p",[n._v("直接找到字符串的所有子字符串，进行长度比较，时间复杂度 O(n^2)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let max = 0;\nlet map = new Map();\nfor (let i = 0; i < s.length; i++) {\n    let tempMax = 0;\n    let tempS = s.substring(i);\n    for (let temp of tempS) {\n        if (!map.has(temp)) {\n            map.set(temp, 1);\n            tempMax = tempMax + 1;\n            if (tempMax > max) max = tempMax;\n        } else {\n            map.clear();\n            break;\n        }\n    }\n}\nreturn max;\n")])])]),e("p",[e("strong",[n._v("2.滑动窗口解法（双指针）")])]),n._v(" "),e("p",[n._v("设置左右两个指针，如果右指针对应的元素不在 set 中，则加入 set，移动右指针；如果右指针对应的元素在 set 中，则"),e("strong",[n._v("一直")]),n._v("移动左指针，并删除左指针在 set 中对应的元素，"),e("strong",[n._v("使得右指针能够满足条件")]),n._v("（之所以移动左指针是因为这时候已经发生重复了，移动右指针依然重复，没有意义）。当右指针到达字符串尾端时，循环结束，时间复杂度 O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let left = right = length = maxLength = 0;\nlet set = new Set();\nwhile (right < s.length) {\n    if (!set.has(s[right])) {\n        set.add(s[right]);\n        right++;\n        length++;\n        if (length > maxLength) maxLength = length;\n    } else {\n        while (set.has(s[right])) {\n            set.delete(s[left]);\n            left++;\n            length--;\n        }\n    }\n}\nreturn maxLength;\n")])])]),e("h2",{attrs:{id:"_88-合并两个有序数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_88-合并两个有序数组"}},[n._v("#")]),n._v(" 88.合并两个有序数组")]),n._v(" "),e("p",[n._v("给你两个按 "),e("strong",[n._v("非递减顺序")]),n._v(" 排列的整数数组 "),e("code",[n._v("nums1")]),n._v(" 和 "),e("code",[n._v("nums2")]),n._v("，另有两个整数 "),e("code",[n._v("m")]),n._v(" 和 "),e("code",[n._v("n")]),n._v(" ，分别表示 "),e("code",[n._v("nums1")]),n._v(" 和 "),e("code",[n._v("nums2")]),n._v(" 中的元素数目。")]),n._v(" "),e("p",[n._v("请你 "),e("strong",[n._v("合并")]),n._v(" "),e("code",[n._v("nums2")]),n._v(" 到 "),e("code",[n._v("nums1")]),n._v(" 中，使合并后的数组同样按 "),e("strong",[n._v("非递减顺序")]),n._v(" 排列。")]),n._v(" "),e("p",[e("strong",[n._v("注意：")]),n._v(" 最终，合并后数组不应由函数返回，而是存储在数组 "),e("code",[n._v("nums1")]),n._v(" 中。为了应对这种情况，"),e("code",[n._v("nums1")]),n._v(" 的初始长度为 "),e("code",[n._v("m + n")]),n._v("，其中前 "),e("code",[n._v("m")]),n._v(" 个元素表示应合并的元素，后 "),e("code",[n._v("n")]),n._v(" 个元素为 "),e("code",[n._v("0")]),n._v(" ，应忽略。"),e("code",[n._v("nums2")]),n._v(" 的长度为 "),e("code",[n._v("n")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n解释：需要合并 [1,2,3] 和 [2,5,6] 。\n合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n解释：需要合并 [1] 和 [] 。\n合并结果是 [1] 。\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums1 = [0], m = 0, nums2 = [1], n = 1\n输出：[1]\n解释：需要合并的数组是 [] 和 [1] 。\n合并结果是 [1] 。\n注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("nums1.length == m + n")])]),n._v(" "),e("li",[e("code",[n._v("nums2.length == n")])]),n._v(" "),e("li",[e("code",[n._v("0 <= m, n <= 200")])]),n._v(" "),e("li",[e("code",[n._v("1 <= m + n <= 200")])]),n._v(" "),e("li",[e("code",[n._v("-109 <= nums1[i], nums2[j] <= 109")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")]),n._v(" 你可以设计实现一个时间复杂度为 "),e("code",[n._v("O(m + n)")]),n._v(" 的算法解决此问题吗？")]),n._v(" "),e("p",[e("strong",[n._v("1.双指针法")])]),n._v(" "),e("p",[n._v("每个数组设置一个指针，其中数值小于等于另一个指针指向元素的指针向右移动，当移动至数组末尾时，跳出循环，直接收集另一指针剩余的全部元素即可，时间复杂度 O(m+n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let p1 = 0;\nlet p2 = 0;\nlet nums = [];\nwhile (p1 < m && p2 < n) {\n    if (nums1[p1] <= nums2[p2]) {\n        nums.push(nums1[p1]);\n        p1++;\n    } else {\n        nums.push(nums2[p2]);\n        p2++;\n    }\n}\nif (p1 === m) {\n    while (p2 < n) {\n        nums.push(nums2[p2]);\n        p2++;\n    }\n} else {\n\twhile (p1 < m) {\n        nums.push(nums1[p1]);\n        p1++;\n    }\n}\nnums1.splice(0, m + n);\nfor (let i = 0; i < nums.length; i++) {\n    nums1.push(nums[i]);\n}\n")])])]),e("p",[n._v("注意，上述方法会产生一个临时数组，内存消耗大，因此可以采用对nums1数组从后往前进行元素覆盖的方式（如果从前往后可能会覆盖掉nums1原有的元素），不断选出最大的元素插入到数组尾部，时间复杂度 O(m+n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let p1 = m - 1;\nlet p2 = n - 1;\nlet k = m + n - 1;\nwhile (p1 >= 0 && p2 >= 0) {\n    if (nums1[p1] > nums2[p2]) {\n      nums1[k--] = nums1[p1--];\n    } else {\n      nums1[k--] = nums2[p2--];\n    }\n}\nwhile (p2 >= 0) {\n    nums1[k--] = nums2[p2--];\n}\n")])])]),e("h2",{attrs:{id:"_165-比较版本号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_165-比较版本号"}},[n._v("#")]),n._v(" 165.比较版本号")]),n._v(" "),e("p",[n._v("给你两个 "),e("strong",[n._v("版本号字符串")]),n._v(" "),e("code",[n._v("version1")]),n._v(" 和 "),e("code",[n._v("version2")]),n._v(" ，请你比较它们。版本号由被点 "),e("code",[n._v("'.'")]),n._v(" 分开的修订号组成。"),e("strong",[n._v("修订号的值")]),n._v(" 是它 "),e("strong",[n._v("转换为整数")]),n._v(" 并忽略前导零。")]),n._v(" "),e("p",[n._v("比较版本号时，请按 "),e("strong",[n._v("从左到右的顺序")]),n._v(" 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 "),e("code",[n._v("0")]),n._v("。")]),n._v(" "),e("p",[n._v("返回规则如下：")]),n._v(" "),e("ul",[e("li",[n._v("如果 "),e("code",[n._v("version1 < version2")]),n._v(" 返回 "),e("code",[n._v("-1")]),n._v("，")]),n._v(" "),e("li",[n._v("如果 "),e("code",[n._v("version1 > version2")]),n._v("返回  "),e("code",[n._v("1")]),n._v("，")]),n._v(" "),e("li",[n._v("除此之外返回 "),e("code",[n._v("0")]),n._v("。")])]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输入：")]),n._v(' version1 = "1.2", version2 = "1.10"')]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输出：")]),n._v(" -1")]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("解释：")])]),n._v(" "),e("p",[n._v('​\t\tversion1 的第二个修订号为 "2"，version2 的第二个修订号为 "10"：2 < 10，所以 version1 < version2。')]),n._v(" "),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输入：")]),n._v(' version1 = "1.01", version2 = "1.001"')]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输出：")]),n._v(" 0")]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("解释：")])]),n._v(" "),e("p",[n._v('​\t\t忽略前导零，"01" 和 "001" 都代表相同的整数 "1"。')]),n._v(" "),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输入：")]),n._v(' version1 = "1.0", version2 = "1.0.0.0"')]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("输出：")]),n._v(" 0")]),n._v(" "),e("p",[n._v("​\t\t"),e("strong",[n._v("解释：")])]),n._v(" "),e("p",[n._v('​\t\tversion1 有更少的修订号，每个缺失的修订号按 "0" 处理。')]),n._v(" "),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= version1.length, version2.length <= 500")])]),n._v(" "),e("li",[e("code",[n._v("version1")]),n._v(" 和 "),e("code",[n._v("version2")]),n._v(" 仅包含数字和 "),e("code",[n._v("'.'")])]),n._v(" "),e("li",[e("code",[n._v("version1")]),n._v(" 和 "),e("code",[n._v("version2")]),n._v(" 都是 "),e("strong",[n._v("有效版本号")])]),n._v(" "),e("li",[e("code",[n._v("version1")]),n._v(" 和 "),e("code",[n._v("version2")]),n._v(" 的所有修订号都可以存储在 "),e("strong",[n._v("32 位整数")]),n._v(" 中")])]),n._v(" "),e("p",[e("strong",[n._v("1.split分割法")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('let arr1 = version1.split(".");\nlet arr2 = version2.split(".");\nif (arr1.length >= arr2.length) {\n    for (let i = 0; i < arr1.length; i++) {\n      if (i > arr2.length - 1) {\n        arr2.push("0");\n      }\n    }\n} else {\n    for (let i = 0; i < arr2.length; i++) {\n      if (i > arr1.length - 1) {\n        arr1.push("0");\n      }\n    }\n}\nfor (let i = 0; i < arr1.length; i++) {\n    if (Number(arr1[i]) > Number(arr2[i])) return 1;\n    else if (Number(arr1[i]) < Number(arr2[i])) return -1;\n}\nreturn 0;\n')])])]),e("p",[e("strong",[n._v("2.遍历法（不用split）")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('let arr1 = [];\nlet arr2 = [];\nlet str = "";\nfor (let i = 0; i < version1.length; i++) {\n    if (version1[i] !== ".") str += version1[i];\n    else {\n      arr1.push(str);\n      str = "";\n    }\n}\narr1.push(str);\nstr = "";\nfor (let i = 0; i < version2.length; i++) {\n    if (version2[i] !== ".") str += version2[i];\n    else {\n      arr2.push(str);\n      str = "";\n    }\n}\narr2.push(str);\nif (arr1.length >= arr2.length) {\n    for (let i = 0; i < arr1.length; i++) {\n      if (i > arr2.length - 1) {\n        arr2.push("0");\n      }\n    }\n} else {\n    for (let i = 0; i < arr2.length; i++) {\n      if (i > arr1.length - 1) {\n        arr1.push("0");\n      }\n    }\n}\nfor (let i = 0; i < arr1.length; i++) {\n    if (Number(arr1[i]) > Number(arr2[i])) return 1;\n    else if (Number(arr1[i]) < Number(arr2[i])) return -1;\n}\nreturn 0;\n')])])]),e("p",[e("strong",[n._v("3.双指针法")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('let p1 = 0;\nlet p2 = 0;\nwhile (p1 < version1.length || p2 < version2.length) {\n    let num1 = 0;\n    for (; p1 < version1.length && version1[p1] !== "."; p1++) {\n        num1 = num1 * 10 + (version1[p1] - "0");\n    }\n    let num2 = 0;\n    for (; p2 < version2.length && version2[p2] !== "."; p2++) {\n        num2 = num2 * 10 + (version2[p2] - "0");\n    }\n    if (num1 !== num2) return num1 > num2 ? 1 : -1;\n    p1++;\n    p2++;\n}\nreturn 0;\n')])])]),e("h2",{attrs:{id:"_1-两数之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-两数之和"}},[n._v("#")]),n._v(" 1.两数之和")]),n._v(" "),e("p",[n._v("给定一个整数数组 "),e("code",[n._v("nums")]),n._v(" 和一个整数目标值 "),e("code",[n._v("target")]),n._v("，请你在该数组中找出 "),e("strong",[n._v("和为目标值")]),n._v(" "),e("em",[e("code",[n._v("target")])]),n._v(" 的那 "),e("strong",[n._v("两个")]),n._v(" 整数，并返回它们的数组下标。")]),n._v(" "),e("p",[n._v("你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。")]),n._v(" "),e("p",[n._v("你可以按任意顺序返回答案。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [3,2,4], target = 6\n输出：[1,2]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [3,3], target = 6\n输出：[0,1]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("2 <= nums.length <= 104")])]),n._v(" "),e("li",[e("code",[n._v("-109 <= nums[i] <= 109")])]),n._v(" "),e("li",[e("code",[n._v("-109 <= target <= 109")])]),n._v(" "),e("li",[e("strong",[n._v("只会存在一个有效答案")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")]),n._v(" 你可以想出一个时间复杂度小于 "),e("code",[n._v("O(n2)")]),n._v(" 的算法吗？")]),n._v(" "),e("p",[e("strong",[n._v("1.双指针法")])]),n._v(" "),e("p",[n._v("在保留原始索引的前提下，先排序，然后用双指针首尾相向靠近，直到找到解，时间复杂度O(nlogn)，主要耗时在排序这一过程：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let p1 = 0;\nlet p2 = nums.length - 1;\nnums = nums.map((item, index) => {\n    return { item, index };\n});\nnums.sort(function (a, b) {\n    return a.item - b.item;\n});\nwhile (p1 < p2) {\n    if (nums[p1].item + nums[p2].item < target) p1++;\n    else if (nums[p1].item + nums[p2].item > target) p2--;\n    else return [nums[p1].index, nums[p2].index];\n}\n")])])]),e("p",[e("strong",[n._v("2.哈希Map法")])]),n._v(" "),e("p",[n._v("通过Map存储元素及索引，用距离target的差值判断是否有对应元素，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("const map = new Map();\nfor (let index = 0; index < nums.length; index++) {\n    const diff = target - nums[index];\n    if (!map.has(diff)) map.set(nums[index], index);\n    else return [map.get(diff), index];\n}\nreturn [];\n")])])]),e("h2",{attrs:{id:"_415-字符串相加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_415-字符串相加"}},[n._v("#")]),n._v(" 415.字符串相加")]),n._v(" "),e("p",[n._v("给定两个字符串形式的非负整数 "),e("code",[n._v("num1")]),n._v(" 和"),e("code",[n._v("num2")]),n._v(" ，计算它们的和并同样以字符串形式返回。")]),n._v(" "),e("p",[n._v("你不能使用任何內建的用于处理大整数的库（比如 "),e("code",[n._v("BigInteger")]),n._v("）， 也不能直接将输入的字符串转换为整数形式。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：num1 = "11", num2 = "123"\n输出："134"\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：num1 = "456", num2 = "77"\n输出："533"\n')])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：num1 = "0", num2 = "0"\n输出："0"\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= num1.length, num2.length <= 104")])]),n._v(" "),e("li",[e("code",[n._v("num1")]),n._v(" 和"),e("code",[n._v("num2")]),n._v(" 都只包含数字 "),e("code",[n._v("0-9")])]),n._v(" "),e("li",[e("code",[n._v("num1")]),n._v(" 和"),e("code",[n._v("num2")]),n._v(" 都不包含任何前导零")])]),n._v(" "),e("p",[e("strong",[n._v("1.进位加法")])]),n._v(" "),e("p",[n._v("仿照现实中两数相加的方法，从后往前进行加法运算，同时考虑进位，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('let sum = "";\nlet carry = 0;\nif (num1.length < num2.length) num1 = num1.padStart(num2.length, "0");\nelse num2 = num2.padStart(num1.length, "0");\nfor (let i = num1.length - 1; i >= 0; i--) {\n    if (num1[i] - "0" + (num2[i] - "0") + carry >= 10) {\n        sum = num1[i] - "0" + (num2[i] - "0") + carry - 10 + sum;\n        carry = 1;\n    } else {\n        sum = num1[i] - "0" + (num2[i] - "0") + carry + sum;\n        carry = 0;\n    }\n}\nif (carry === 1) sum = 1 + sum;\nreturn sum;\n')])])]),e("h2",{attrs:{id:"_20-有效的括号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-有效的括号"}},[n._v("#")]),n._v(" 20.有效的括号")]),n._v(" "),e("p",[n._v("给定一个只包括 "),e("code",[n._v("'('")]),n._v("，"),e("code",[n._v("')'")]),n._v("，"),e("code",[n._v("'{'")]),n._v("，"),e("code",[n._v("'}'")]),n._v("，"),e("code",[n._v("'['")]),n._v("，"),e("code",[n._v("']'")]),n._v(" 的字符串 "),e("code",[n._v("s")]),n._v(" ，判断字符串是否有效。")]),n._v(" "),e("p",[n._v("有效字符串需满足：")]),n._v(" "),e("ol",[e("li",[n._v("左括号必须用相同类型的右括号闭合。")]),n._v(" "),e("li",[n._v("左括号必须以正确的顺序闭合。")]),n._v(" "),e("li",[n._v("每个右括号都有一个对应的相同类型的左括号。")])]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("strong",[n._v("输入：")]),n._v(' s = "()"')]),n._v(" "),e("p",[e("strong",[n._v("输出：")]),n._v(" true")]),n._v(" "),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("strong",[n._v("输入：")]),n._v(' s = "()[]{}"')]),n._v(" "),e("p",[e("strong",[n._v("输出：")]),n._v(" true")]),n._v(" "),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("p",[e("strong",[n._v("输入：")]),n._v(' s = "(]"')]),n._v(" "),e("p",[e("strong",[n._v("输出：")]),n._v(" false")]),n._v(" "),e("p",[e("strong",[n._v("示例 4：")])]),n._v(" "),e("p",[e("strong",[n._v("输入：")]),n._v(' s = "([])"')]),n._v(" "),e("p",[e("strong",[n._v("输出：")]),n._v(" true")]),n._v(" "),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= s.length <= 104")])]),n._v(" "),e("li",[e("code",[n._v("s")]),n._v(" 仅由括号 "),e("code",[n._v("'()[]{}'")]),n._v(" 组成")])]),n._v(" "),e("p",[e("strong",[n._v("1.栈存储法")])]),n._v(" "),e("p",[n._v("碰到左括号压栈，碰到右括号则将栈中元素弹出，如果与右括号匹配则继续，不匹配则失败，注意栈中只存放左括号，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('let stack = [];\nfor (let i = 0; i < s.length; i++) {\n    if (s[i] === "(" || s[i] === "{" || s[i] === "[") {\n        stack.push(s[i]);\n    } else if (s[i] === ")") {\n        if (stack.pop() === "(") continue;\n        else return false;\n    } else if (s[i] === "}") {\n        if (stack.pop() === "{") continue;\n        else return false;\n    } else if (s[i] === "]") {\n        if (stack.pop() === "[") continue;\n        else return false;\n    }\n}\nif (stack.length === 0) return true;\nelse return false;\n')])])]),e("h2",{attrs:{id:"_46-全排列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_46-全排列"}},[n._v("#")]),n._v(" 46.全排列")]),n._v(" "),e("p",[n._v("给定一个不含重复数字的数组 "),e("code",[n._v("nums")]),n._v(" ，返回其 "),e("em",[n._v("所有可能的全排列")]),n._v(" 。你可以 "),e("strong",[n._v("按任意顺序")]),n._v(" 返回答案。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [1]\n输出：[[1]]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= nums.length <= 6")])]),n._v(" "),e("li",[e("code",[n._v("-10 <= nums[i] <= 10")])]),n._v(" "),e("li",[e("code",[n._v("nums")]),n._v(" 中的所有整数 "),e("strong",[n._v("互不相同")])])]),n._v(" "),e("p",[e("strong",[n._v("1.回溯法")])]),n._v(" "),e("p",[n._v("通过递归方式进行回溯，每一次搜索为深度优先搜索，考虑完当前可能性，则返回上一步继续搜索（返回的这种思路即为回溯），时间复杂度O(n!)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let res = [];\ndfs([]);\nfunction dfs(arr) {\n    if (arr.length === nums.length) {\n        res.push([...arr]);\n        return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (arr.includes(nums[i])) continue;\n        arr.push(nums[i]);\n        dfs(arr);\n        arr.pop();\n    }\n}\nreturn res;\n")])])]),e("h2",{attrs:{id:"_206-反转链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_206-反转链表"}},[n._v("#")]),n._v(" 206.反转链表")]),n._v(" "),e("p",[n._v("给你单链表的头节点 "),e("code",[n._v("head")]),n._v(" ，请你反转链表，并返回反转后的链表。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1,2]\n输出：[2,1]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("链表中节点的数目范围是 "),e("code",[n._v("[0, 5000]")])]),n._v(" "),e("li",[e("code",[n._v("-5000 <= Node.val <= 5000")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")]),n._v("  链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？")]),n._v(" "),e("p",[e("strong",[n._v("1.迭代法")])]),n._v(" "),e("p",[n._v("创建temp、cur、next三个指针，对链表进行迭代，完成反转，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (head === null || head.next === null) return head;\nlet temp = null;\nlet cur = head;\nlet next = head;\nwhile (cur !== null) {\n    next = cur.next;\n    cur.next = temp;\n    temp = cur;\n    cur = next;\n}\nreturn temp;\n")])])]),e("p",[e("strong",[n._v("2.递归法")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (head === null || head.next === null) return head;\nlet res = reverseList(head.next);\nhead.next.next = head;\nhead.next = null;\nreturn res;\n")])])]),e("h2",{attrs:{id:"_53-最大子数组和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_53-最大子数组和"}},[n._v("#")]),n._v(" 53.最大子数组和")]),n._v(" "),e("p",[n._v("给你一个整数数组 "),e("code",[n._v("nums")]),n._v(" ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。")]),n._v(" "),e("p",[e("strong",[n._v("子数组")])]),n._v(" "),e("p",[n._v("是数组中的一个连续部分。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [1]\n输出：1\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [5,4,-1,7,8]\n输出：23\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= nums.length <= 105")])]),n._v(" "),e("li",[e("code",[n._v("-104 <= nums[i] <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")]),n._v(" 如果你已经实现复杂度为 "),e("code",[n._v("O(n)")]),n._v(" 的解法，尝试使用更为精妙的 "),e("strong",[n._v("分治法")]),n._v(" 求解。")]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("dp五部曲：")]),n._v(" "),e("p",[n._v("1.dp数组以及下标含义")]),n._v(" "),e("p",[n._v("2.递推公式")]),n._v(" "),e("p",[n._v("3.dp数组如何初始化")]),n._v(" "),e("p",[n._v("4.遍历顺序")]),n._v(" "),e("p",[n._v("5.打印数组")]),n._v(" "),e("p",[n._v("dp[i]代表以i为结尾的数组的最大连续子序列的和，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let dp = [];\ndp[0] = nums[0];\nlet result = nums[0];\nfor (let i = 1; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);\n    if (dp[i] > result) result = dp[i];\n}\nreturn result;\n")])])]),e("p",[e("strong",[n._v("2.贪心")])]),n._v(" "),e("p",[n._v("当前求和为负数时就从下一个元素重新开始计算，因为负数加负数会越来越小，而负数对正数来说是拖累，因此不管后面的数是正数还是负数，都应该舍弃当前的求和，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let result = nums[0];\nlet sum = 0;\nfor (let i = 0; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > result) result = sum;\n    if (sum < 0) sum = 0;\n}\nreturn result;\n")])])]),e("h2",{attrs:{id:"_102-二叉树的层序遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_102-二叉树的层序遍历"}},[n._v("#")]),n._v(" 102.二叉树的层序遍历")]),n._v(" "),e("p",[n._v("给你二叉树的根节点 "),e("code",[n._v("root")]),n._v(" ，返回其节点值的 "),e("strong",[n._v("层序遍历")]),n._v(" 。 （即逐层地，从左到右访问所有节点）。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[9,20],[15,7]]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1]\n输出：[[1]]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点数目在范围 "),e("code",[n._v("[0, 2000]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("-1000 <= Node.val <= 1000")])])]),n._v(" "),e("p",[e("strong",[n._v("1.队列法")])]),n._v(" "),e("p",[n._v("用队列收集元素，每次弹出元素时都压入它的左右子元素，当队列为空时结束循环，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (!root) return [];\nlet result = [];\nlet queue = [root];\nwhile (queue.length) {\n    let subRes = [];\n    let size = queue.length;\n    for (let i = 0; i < size; i++) {\n        let cur = queue.shift();\n        subRes.push(cur.val);\n        if (cur.left) queue.push(cur.left);\n        if (cur.right) queue.push(cur.right);\n    }\n    result.push(subRes);\n}\nreturn result;\n")])])]),e("h2",{attrs:{id:"_121-买卖股票的最佳时机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_121-买卖股票的最佳时机"}},[n._v("#")]),n._v(" 121.买卖股票的最佳时机")]),n._v(" "),e("p",[n._v("给定一个数组 "),e("code",[n._v("prices")]),n._v(" ，它的第 "),e("code",[n._v("i")]),n._v(" 个元素 "),e("code",[n._v("prices[i]")]),n._v(" 表示一支给定股票第 "),e("code",[n._v("i")]),n._v(" 天的价格。")]),n._v(" "),e("p",[n._v("你只能选择 "),e("strong",[n._v("某一天")]),n._v(" 买入这只股票，并选择在 "),e("strong",[n._v("未来的某一个不同的日子")]),n._v(" 卖出该股票。设计一个算法来计算你所能获取的最大利润。")]),n._v(" "),e("p",[n._v("返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 "),e("code",[n._v("0")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= prices.length <= 105")])]),n._v(" "),e("li",[e("code",[n._v("0 <= prices[i] <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("dp[i]代表前i天的最大利润，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let dp = [0];\nlet index = 0;\nlet result = 0;\nfor (let i = 1; i < prices.length; i++) {\n    if (prices[i] < prices[index]) index = i;\n    dp[i] = Math.max(dp[i - 1], prices[i] - prices[index]);\n    if (dp[i] > result) result = dp[i];\n}\nreturn result;\n")])])]),e("p",[e("strong",[n._v("2.贪心")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let max = 0;\nlet minPrice = prices[0];\nfor (let i = 1; i < prices.length; i++) {\n    minPrice = Math.min(prices[i], minPrice);\n    max = Math.max(max, prices[i] - minPrice)\n}\nreturn max;\n")])])]),e("h2",{attrs:{id:"_15-三数之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-三数之和"}},[n._v("#")]),n._v(" 15.三数之和")]),n._v(" "),e("p",[n._v("给你一个整数数组 "),e("code",[n._v("nums")]),n._v(" ，判断是否存在三元组 "),e("code",[n._v("[nums[i], nums[j], nums[k]]")]),n._v(" 满足 "),e("code",[n._v("i != j")]),n._v("、"),e("code",[n._v("i != k")]),n._v(" 且 "),e("code",[n._v("j != k")]),n._v(" ，同时还满足 "),e("code",[n._v("nums[i] + nums[j] + nums[k] == 0")]),n._v(" 。请你返回所有和为 "),e("code",[n._v("0")]),n._v(" 且不重复的三元组。")]),n._v(" "),e("p",[e("strong",[n._v("注意：")]),n._v(" 答案中不可以包含重复的三元组。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("3 <= nums.length <= 3000")])]),n._v(" "),e("li",[e("code",[n._v("-105 <= nums[i] <= 105")])])]),n._v(" "),e("p",[e("strong",[n._v("1.双指针法")])]),n._v(" "),e("p",[n._v("虽说是双指针法，其实是三指针i，left，right，先固定i，然后移动left和right，这一过程中需要注意两次去重，一次是i指针的去重，另一次是left和right指针的去重，时间复杂度O(n^2)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let result = [];\nnums.sort((a, b) => {\n    return a - b;\n});\nfor (let i = 0; i < nums.length; i++) {\n    if (nums[i] > 0) break;\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let left = i + 1;\n    let right = nums.length - 1;\n    while (right > left) {\n        if (nums[i] + nums[left] + nums[right] > 0) right--;\n        else if (nums[i] + nums[left] + nums[right] < 0) left++;\n        else {\n            result.push([nums[i], nums[left], nums[right]]);\n            while (right > left && nums[right] === nums[right - 1]) right--;\n            while (right > left && nums[left] === nums[left + 1]) left++;\n            left++;\n            right--;\n        }\n    }\n}\nreturn result;\n")])])]),e("h2",{attrs:{id:"_112-路径总和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_112-路径总和"}},[n._v("#")]),n._v(" 112.路径总和")]),n._v(" "),e("p",[n._v("给你二叉树的根节点 "),e("code",[n._v("root")]),n._v(" 和一个表示目标和的整数 "),e("code",[n._v("targetSum")]),n._v(" 。判断该树中是否存在 "),e("strong",[n._v("根节点到叶子节点")]),n._v(" 的路径，这条路径上所有节点值相加等于目标和 "),e("code",[n._v("targetSum")]),n._v(" 。如果存在，返回 "),e("code",[n._v("true")]),n._v(" ；否则，返回 "),e("code",[n._v("false")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("叶子节点")]),n._v(" 是指没有子节点的节点。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n输出：true\n解释：等于目标和的根节点到叶节点路径如上图所示。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,2,3], targetSum = 5\n输出：false\n解释：树中存在两条根节点到叶子节点的路径：\n(1 --\x3e 2): 和为 3\n(1 --\x3e 3): 和为 4\n不存在 sum = 5 的根节点到叶子节点的路径。\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [], targetSum = 0\n输出：false\n解释：由于树是空的，所以不存在根节点到叶子节点的路径。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点的数目在范围 "),e("code",[n._v("[0, 5000]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("-1000 <= Node.val <= 1000")])]),n._v(" "),e("li",[e("code",[n._v("-1000 <= targetSum <= 1000")])])]),n._v(" "),e("p",[e("strong",[n._v("1.递归法")])]),n._v(" "),e("p",[n._v("每遍历到一个节点就用目标值减去节点的值，当目标值为0且节点是叶子节点则成功找到，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function dfs(root, val) {\n    if (!root) return false;\n    if (val - root.val === 0 && (!root.left) && (!root.right)) return true;\n    return dfs(root.left, val - root.val) || dfs(root.right, val - root.val);\n}\nreturn dfs(root, targetSum);\n")])])]),e("h2",{attrs:{id:"_141-环形链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_141-环形链表"}},[n._v("#")]),n._v(" 141.环形链表")]),n._v(" "),e("p",[n._v("给你一个链表的头节点 "),e("code",[n._v("head")]),n._v(" ，判断链表中是否有环。")]),n._v(" "),e("p",[n._v("如果链表中有某个节点，可以通过连续跟踪 "),e("code",[n._v("next")]),n._v(" 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 "),e("code",[n._v("pos")]),n._v(" 来表示链表尾连接到链表中的位置（索引从 0 开始）。"),e("strong",[n._v("注意："),e("code",[n._v("pos")]),n._v(" 不作为参数进行传递")]),n._v(" 。仅仅是为了标识链表的实际情况。")]),n._v(" "),e("p",[e("em",[n._v("如果链表中存在环")]),n._v(" ，则返回 "),e("code",[n._v("true")]),n._v(" 。 否则，返回 "),e("code",[n._v("false")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("链表中节点的数目范围是 "),e("code",[n._v("[0, 104]")])]),n._v(" "),e("li",[e("code",[n._v("-105 <= Node.val <= 105")])]),n._v(" "),e("li",[e("code",[n._v("pos")]),n._v(" 为 "),e("code",[n._v("-1")]),n._v(" 或者链表中的一个 "),e("strong",[n._v("有效索引")]),n._v(" 。")])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")]),n._v(" 你能用 "),e("code",[n._v("O(1)")]),n._v("（即，常量）内存解决此问题吗？")]),n._v(" "),e("p",[e("strong",[n._v("1.节点数法")])]),n._v(" "),e("p",[n._v("已知节点数最多10000个，则可设置一个累加数值，当大于10000时必然存在环，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("p",[n._v("此方法纯粹为了解题，不推荐使用：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let k = 0;\nwhile (head !== null) {\n    k++;\n    head = head.next;\n    if (k > 10000) return true;\n}\nreturn false;\n")])])]),e("p",[e("strong",[n._v("2.哈希表法")])]),n._v(" "),e("p",[n._v("通过哈希表存放指针地址，如果新加入的指针地址已存在，则说明存在环，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let map = new Map();\nwhile (head) {\n    if (map.get(head)) return true;\n    else map.set(head, true);\n    head = head.next;\n}\nreturn false;\n")])])]),e("p",[e("strong",[n._v("3.快慢指针法")])]),n._v(" "),e("p",[n._v("设置慢指针slow，快指针fast，慢指针一次走一步，快指针一次走两步，如果存在环，则快慢指针必定会在某时刻重合，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("if (!head) return false;\nlet slow = head;\nlet fast = head;\nwhile (fast.next && fast.next.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n}\nreturn false;\n")])])]),e("h2",{attrs:{id:"_70-爬楼梯"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_70-爬楼梯"}},[n._v("#")]),n._v(" 70.爬楼梯")]),n._v(" "),e("p",[n._v("假设你正在爬楼梯。需要 "),e("code",[n._v("n")]),n._v(" 阶你才能到达楼顶。")]),n._v(" "),e("p",[n._v("每次你可以爬 "),e("code",[n._v("1")]),n._v(" 或 "),e("code",[n._v("2")]),n._v(" 个台阶。你有多少种不同的方法可以爬到楼顶呢？")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= n <= 45")])])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("因为一次只能爬1或2个阶梯，所以到达第i阶肯定是从第i-1阶爬1阶或第i-2阶爬2阶上来的，因此爬到前两阶的方法总和就是爬到第i阶的方法总和，dp[i]代表到达i阶有dp[i]种方法，时间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let dp = [];\ndp[1] = 1, dp[2] = 2;\nif (n === 1 || n === 2) return dp[n];\nfor (let i = 3; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n}\nreturn dp[n];\n")])])]),e("h2",{attrs:{id:"_215-数组中的第k个最大元素"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_215-数组中的第k个最大元素"}},[n._v("#")]),n._v(" 215.数组中的第K个最大元素")]),n._v(" "),e("p",[n._v("给定整数数组 "),e("code",[n._v("nums")]),n._v(" 和整数 "),e("code",[n._v("k")]),n._v("，请返回数组中第 "),e("code",[n._v("k")]),n._v(" 个最大的元素。")]),n._v(" "),e("p",[n._v("请注意，你需要找的是数组排序后的第 "),e("code",[n._v("k")]),n._v(" 个最大的元素，而不是第 "),e("code",[n._v("k")]),n._v(" 个不同的元素。")]),n._v(" "),e("p",[n._v("你必须设计并实现时间复杂度为 "),e("code",[n._v("O(n)")]),n._v(" 的算法解决此问题。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: [3,2,1,5,6,4], k = 2\n输出: 5\n")])])]),e("p",[e("strong",[n._v("示例 2:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: [3,2,3,1,2,4,5,5,6], k = 4\n输出: 4\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= k <= nums.length <= 105")])]),n._v(" "),e("li",[e("code",[n._v("-104 <= nums[i] <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("1.数组法")])]),n._v(" "),e("p",[n._v("将元素作为数组下标存入，时间复杂度O(n)，但如果元素之间大小差距大则会产生很多不必要的遍历，不推荐这个方法：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let arr = [];\nfor (let i = 0; i < nums.length; i++) {\n    if (arr[nums[i]] === undefined) arr[nums[i]] = 1;\n    else arr[nums[i]]++;\n}\nfor (let i = arr.length - 1; ; i--) {\n    if (arr[i] !== undefined && arr[i] >= 1) k -= arr[i];\n    if (k <= 0) return i;\n}\n")])])]),e("p",[e("strong",[n._v("2.小顶堆")])]),n._v(" "),e("p",[n._v("通过构造一个前k个最大元素小顶堆来解决，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。")]),n._v(" "),e("p",[n._v("可以从数组中取出k个元素构造一个小顶堆，然后将其余元素与小顶堆对比，如果大于堆顶则替换堆顶，然后堆化，所有元素遍历完成后，堆中的堆顶即为第k个最大值。时间复杂度O(nlogk)，空间复杂度O(k)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n    // 从 nums 中取出前 k 个数，构建一个小顶堆\n    let heap = [,], i = 0\n    while(i < k) {\n       heap.push(nums[i++]) \n    }\n    buildHeap(heap, k)\n    \n    // 从 k 位开始遍历数组\n    for(let i = k; i < nums.length; i++) {\n        if(heap[1] < nums[i]) {\n            // 替换并堆化\n            heap[1] = nums[i]\n            heapify(heap, k, 1)\n        }\n    }\n    \n    // 返回堆顶元素\n    return heap[1]\n};\n\n// 原地建堆，从后往前，自上而下式建小顶堆\nlet buildHeap = (arr, k) => {\n    if(k === 1) return\n    // 从最后一个非叶子节点开始，自上而下式堆化\n    for(let i = Math.floor(k/2); i>=1 ; i--) {\n        heapify(arr, k, i)\n    }\n}\n\n// 堆化\nlet heapify = (arr, k, i) => {\n    // 自上而下式堆化\n    while(true) {\n        let minIndex = i\n        if(2*i <= k && arr[2*i] < arr[i]) {\n            minIndex = 2*i\n        }\n        if(2*i+1 <= k && arr[2*i+1] < arr[minIndex]) {\n            minIndex = 2*i+1\n        }\n        if(minIndex !== i) {\n            swap(arr, i, minIndex)\n            // 交换后要重新处理被交换节点，因为换下去的节点可能比被交换节点的子节点大\n            i = minIndex\n        } else {\n            break\n        }\n    }\n}\n\n// 交换\nlet swap = (arr, i , j) => {\n    let temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n}\n")])])]),e("p",[e("strong",[n._v("3.快速选择")])]),n._v(" "),e("p",[n._v("运用快速排序的理念，每次快排都能确定一个元素的最终位置，把快排改成降序，如果当前确定的这个元素的位置正好与k-1相同，则说明已经找到了第k大的元素，可以提前结束快排，"),e("strong",[n._v("注意，在partition中需要先把pivot放在arr的最后面，避免它影响partition过程，否则会出错")]),n._v("，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar findKthLargest = function (nums, k) {\n\tlet left = 0;\n    let right = nums.length - 1;\n    while (left <= right) {\n        let mid = partition(nums, left, right);\n        if (mid === k - 1) return nums[mid];\n        mid > k - 1 ? (right = mid - 1) : (left = mid + 1);\n    }\n}\n\nlet partition = (nums, left, right) => {\n\tlet mid = Math.floor(left + (right - left) / 2);\n    let pivot = nums[mid];\n    // 把pivot放在arr的最后面\n    [nums[mid], nums[right]] = [nums[right], nums[mid]];\n    let i = left;\n    // 把pivot排除在外,不对pivot进行排序\n    let j = right - 1;\n\twhile (i <= j) {\n        while (pivot < nums[i]) i++;\n        while (pivot > nums[j]) j--;\n        if (i <= j) {\n            [nums[i], nums[j]] = [nums[j], nums[i]];\n            i++;\n            j--;\n        }\n    }\n    // 因为arr[i]是属于left的,pivot也是属于left的\n    // 故我们可以把原本保护起来的pivot和现在数组的中间值交换\n    [nums[i], nums[right]] = [nums[right], nums[i]];\n    return i;\n}\n")])])]),e("h2",{attrs:{id:"_5-最长回文子串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-最长回文子串"}},[n._v("#")]),n._v(" 5.最长回文子串")]),n._v(" "),e("p",[n._v("给你一个字符串 "),e("code",[n._v("s")]),n._v("，找到 "),e("code",[n._v("s")]),n._v(" 中最长的 回文 子串。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：s = "babad"\n输出："bab"\n解释："aba" 同样是符合题意的答案。\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：s = "cbbd"\n输出："bb"\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= s.length <= 1000")])]),n._v(" "),e("li",[e("code",[n._v("s")]),n._v(" 仅由数字和英文字母组成")])]),n._v(" "),e("p",[e("strong",[n._v("1.中心扩散法")])]),n._v(" "),e("p",[n._v("先选定一个中心点，然后通过左右指针分别往两边扩散的方式去寻找最长回文子串，注意区分奇数与偶数长度的子串，时间复杂度O(n^2)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let maxLen = 0;\nlet maxIndex = 0;\nfor (let i = 0; i < s.length; i++) {\n    // 奇数长度回文子串\n    let left = (right = i);\n    while (left >= 0 && right <= s.length - 1 && s[left] === s[right]) {\n        if (right - left + 1 > maxLen) {\n            maxLen = right - left + 1;\n            maxIndex = left;\n        }\n        left--;\n        right++;\n    }\n    // 偶数长度回文子串\n    left = i;\n    right = i + 1;\n    while (left >= 0 && right <= s.length - 1 && s[left] === s[right]) {\n        if (right - left + 1 > maxLen) {\n            maxLen = right - left + 1;\n            maxIndex = left;\n        }\n        left--;\n        right++;\n    }\n}\nreturn s.substr(maxIndex, maxLen);\n")])])]),e("p",[e("strong",[n._v("2.动态规划")])]),n._v(" "),e("p",[n._v("维护一个二维dp数组，dp[i][j]代表以i为起始，j为结尾的子串是否是回文串")]),n._v(" "),e("p",[n._v("①s[i]≠s[j]：dp[i][j]=false")]),n._v(" "),e("p",[n._v("②s[i]=s[j]：dp[i][j]=j-i<3||dp[i+1][j-1]")]),n._v(" "),e("p",[n._v("将dp数组填充完毕后，遍历dp数组并根据下标索引计算最长的回文子串")]),n._v(" "),e("p",[n._v("时间复杂度O(n^2)，空间复杂度O(n^2)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("let m = s.length;\nlet dp = Array(m).fill().map(() => Array(m));\nfor (let i = 0; i < m; i++) dp[i][i] = true;\nfor (let j = 1; j < m; j++) {\n    for (let i = 0; i < j; i++) {\n        if (s[i] !== s[j]) dp[i][j] = false;\n        else {\n            dp[i][j] = j - i < 3 || dp[i + 1][j - 1];\n        }\n    }\n}\nlet maxLen = 1;\nlet maxIndex = 0;\nfor (let i = 0; i < m; i++) {\n    for (let j = i + 1; j < m; j++) {\n        if (dp[i][j] && j - i + 1 > maxLen) {\n            maxLen = j - i + 1;\n            maxIndex = i;\n        }\n    }\n}\nreturn s.substr(maxIndex, maxLen);\n")])])]),e("h2",{attrs:{id:"_146-lru缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_146-lru缓存"}},[n._v("#")]),n._v(" 146.LRU缓存")]),n._v(" "),e("p",[n._v("请你设计并实现一个满足 "),e("a",{attrs:{href:"https://baike.baidu.com/item/LRU",target:"_blank",rel:"noopener noreferrer"}},[n._v("LRU (最近最少使用) 缓存"),e("OutboundLink")],1),n._v(" 约束的数据结构。")]),n._v(" "),e("p",[n._v("实现 "),e("code",[n._v("LRUCache")]),n._v(" 类：")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("LRUCache(int capacity)")]),n._v(" 以 "),e("strong",[n._v("正整数")]),n._v(" 作为容量 "),e("code",[n._v("capacity")]),n._v(" 初始化 LRU 缓存")]),n._v(" "),e("li",[e("code",[n._v("int get(int key)")]),n._v(" 如果关键字 "),e("code",[n._v("key")]),n._v(" 存在于缓存中，则返回关键字的值，否则返回 "),e("code",[n._v("-1")]),n._v(" 。")]),n._v(" "),e("li",[e("code",[n._v("void put(int key, int value)")]),n._v(" 如果关键字 "),e("code",[n._v("key")]),n._v(" 已经存在，则变更其数据值 "),e("code",[n._v("value")]),n._v(" ；如果不存在，则向缓存中插入该组 "),e("code",[n._v("key-value")]),n._v(" 。如果插入操作导致关键字数量超过 "),e("code",[n._v("capacity")]),n._v(" ，则应该 "),e("strong",[n._v("逐出")]),n._v(" 最久未使用的关键字。")])]),n._v(" "),e("p",[n._v("函数 "),e("code",[n._v("get")]),n._v(" 和 "),e("code",[n._v("put")]),n._v(" 必须以 "),e("code",[n._v("O(1)")]),n._v(" 的平均时间复杂度运行。")]),n._v(" "),e("p",[e("strong",[n._v("示例：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= capacity <= 3000")])]),n._v(" "),e("li",[e("code",[n._v("0 <= key <= 10000")])]),n._v(" "),e("li",[e("code",[n._v("0 <= value <= 10^5")])]),n._v(" "),e("li",[n._v("最多调用 "),e("code",[n._v("2 * 10^5")]),n._v(" 次 "),e("code",[n._v("get")]),n._v(" 和 "),e("code",[n._v("put")])])]),n._v(" "),e("p",[e("strong",[n._v("1.哈希表+双向链表")])]),n._v(" "),e("p",[n._v("哈希表存key和指针地址，指针存放key和value，用双向链表确定顺序，时间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class Node {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n\nclass DoubleList {\n    constructor() {\n        this.head = new Node(0, 0);\n        this.tail = new Node(0, 0);\n        this.head.next = this.tail;\n        this.tail.prev = this.head;\n        this.size = 0;\n    }\n    addLast(node) {\n        node.prev = this.tail.prev;\n        node.next = this.tail;\n        node.prev.next = node;\n        this.tail.prev = node;\n        this.size++;\n    }\n    remove(node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        this.size--;\n    }\n    removeFirst() {\n        const node = this.head.next;\n        this.remove(node);\n        return node;\n    }\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n    this.cache = new DoubleList();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n    const { map, cache } = this;\n    if (!map.has(key)) return -1;\n    const node = map.get(key);\n    cache.remove(node);\n    cache.addLast(node);\n    return node.value;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n    const { map, cache } = this;\n    if (!map.has(key)) {\n        const node = new Node(key, value);\n        map.set(key, node);\n        cache.addLast(node);\n        cache.size++;\n        if (map.size > this.capacity) {\n            const firstNode = cache.removeFirst();\n            map.delete(firstNode.key);\n            cache.size--;\n        }\n    } else {\n        const node = map.get(key);\n        node.value = value;\n        cache.remove(node);\n        cache.addLast(node);\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n")])])]),e("p",[e("strong",[n._v("2.JS哈希表")])]),n._v(" "),e("p",[n._v("由于JS的哈希表本身就是有序的，因此不需要双向链表来确定顺序，只使用哈希表即可，每次访问或者更新数据时，先将原数据删除，然后重新插入，即可使数据位于哈希表末尾，若长度溢出，则删除哈希表首部数据即可，时间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n};\n\n/**\n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n    if (this.map.get(key) !== undefined) {\n        let value = this.map.get(key);\n        this.map.delete(key);\n        this.map.set(key, value);\n        return value;\n    } else return -1;\n};\n\n/**\n * @param {number} key\n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n    if (this.map.get(key) !== undefined) {\n        this.map.delete(key);\n        this.map.set(key, value);\n    } else {\n        this.map.set(key, value);\n        if (this.map.size > this.capacity) {\n            this.map.delete(this.map.keys().next().value);\n        }\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n")])])]),e("h2",{attrs:{id:"_21-合并两个有序链表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-合并两个有序链表"}},[n._v("#")]),n._v(" 21.合并两个有序链表")]),n._v(" "),e("p",[n._v("将两个升序链表合并为一个新的 "),e("strong",[n._v("升序")]),n._v(" 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [], l2 = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [], l2 = [0]\n输出：[0]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("两个链表的节点数目范围是 "),e("code",[n._v("[0, 50]")])]),n._v(" "),e("li",[e("code",[n._v("-100 <= Node.val <= 100")])]),n._v(" "),e("li",[e("code",[n._v("l1")]),n._v(" 和 "),e("code",[n._v("l2")]),n._v(" 均按 "),e("strong",[n._v("非递减顺序")]),n._v(" 排列")])]),n._v(" "),e("p",[e("strong",[n._v("1.双指针法")])]),n._v(" "),e("p",[n._v("依次比较list1与list2节点的数值，将数值小的加入新链表中，注意可以生成一个dummy节点当做哑节点（头节点），避免特殊的边界处理，方便操作，时间复杂度O(n+m)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n    let current = new ListNode();\n    let dummy = current;\n    while (list1 && list2) {\n        if (list1.val < list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    if (list1) {\n        current.next = list1;\n    }\n    if (list2) {\n        current.next = list2;\n    }\n    return dummy.next;\n};\n")])])]),e("h2",{attrs:{id:"_912-排序数组-手撕快速排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_912-排序数组-手撕快速排序"}},[n._v("#")]),n._v(" 912.排序数组（手撕快速排序）")]),n._v(" "),e("p",[n._v("给你一个整数数组 "),e("code",[n._v("nums")]),n._v("，请你将该数组升序排列。")]),n._v(" "),e("p",[n._v("你必须在 "),e("strong",[n._v("不使用任何内置函数")]),n._v(" 的情况下解决问题，时间复杂度为 "),e("code",[n._v("O(nlog(n))")]),n._v("，并且空间复杂度尽可能小。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [5,2,3,1]\n输出：[1,2,3,5]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [5,1,1,2,0,0]\n输出：[0,0,1,1,2,5]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= nums.length <= 5 * 104")])]),n._v(" "),e("li",[e("code",[n._v("-5 * 104 <= nums[i] <= 5 * 104")])])]),n._v(" "),e("p",[e("strong",[n._v("1.快速排序")])]),n._v(" "),e("p",[n._v("时间复杂度O(nlogn)，空间复杂度O(logn)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar sortArray = function (nums) {\n    if (!nums || nums.length <= 1) return nums;\n    quickSort(nums, 0, nums.length - 1);\n    return nums;\n};\n\nlet quickSort = (arr, left, right) => {\n    if (left < right) {\n        let pivotIndex = partition(arr, left, right);\n        quickSort(arr, left, pivotIndex - 1);\n        quickSort(arr, pivotIndex + 1, right);\n    }\n};\n\nlet partition = (arr, left, right) => {\n    let mid = Math.floor(left + (right - left) / 2);\n    let pivot = arr[mid];\n    [arr[mid], arr[right]] = [arr[right], arr[mid]];\n    let i = left;\n    let j = right - 1;\n    while (i <= j) {\n        while (pivot > arr[i]) i++;\n        while (pivot < arr[j]) j--;\n        if (i <= j) {\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            i++;\n            j--;\n        }\n    }\n    [arr[i], arr[right]] = [arr[right], arr[i]];\n    return i;\n};\n")])])]),e("h2",{attrs:{id:"_54-螺旋矩阵"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_54-螺旋矩阵"}},[n._v("#")]),n._v(" 54.螺旋矩阵")]),n._v(" "),e("p",[n._v("给你一个 "),e("code",[n._v("m")]),n._v(" 行 "),e("code",[n._v("n")]),n._v(" 列的矩阵 "),e("code",[n._v("matrix")]),n._v(" ，请按照 "),e("strong",[n._v("顺时针螺旋顺序")]),n._v(" ，返回矩阵中的所有元素。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("m == matrix.length")])]),n._v(" "),e("li",[e("code",[n._v("n == matrix[i].length")])]),n._v(" "),e("li",[e("code",[n._v("1 <= m, n <= 10")])]),n._v(" "),e("li",[e("code",[n._v("-100 <= matrix[i][j] <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("1.边界缩减法")])]),n._v(" "),e("p",[n._v("维护4个变量边界，不断向中心缩减，注意while循环内每次只走一个方向，而不是一次走四个方向，每走完一轮都要出来判断是否退出循环，不然可能会重复插入元素，时间复杂度O(m*n)，空间复杂度O(m*n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\nvar spiralOrder = function (matrix) {\n    let top = 0;\n    let bottom = matrix.length - 1;\n    let left = 0;\n    let right = matrix[0].length - 1;\n\n    let direction = "right";\n    let result = [];\n\n    while (left <= right && top <= bottom) {\n        if (direction === "right") {\n            for (let i = left; i <= right; i++) {\n                result.push(matrix[top][i]);\n            }\n            top++;\n            direction = "down";\n        } else if (direction === "down") {\n            for (let i = top; i <= bottom; i++) {\n                result.push(matrix[i][right]);\n            }\n            right--;\n            direction = "left";\n        } else if (direction === "left") {\n            for (let i = right; i >= left; i--) {\n                result.push(matrix[bottom][i]);\n            }\n            bottom--;\n            direction = "top";\n        } else if (direction === "top") {\n            for (let i = bottom; i >= top; i--) {\n                result.push(matrix[i][left]);\n            }\n            left++;\n            direction = "right";\n        }\n    }\n    return result;\n};\n')])])]),e("h2",{attrs:{id:"_200-岛屿数量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_200-岛屿数量"}},[n._v("#")]),n._v(" 200.岛屿数量")]),n._v(" "),e("p",[n._v("给你一个由 "),e("code",[n._v("'1'")]),n._v("（陆地）和 "),e("code",[n._v("'0'")]),n._v("（水）组成的的二维网格，请你计算网格中岛屿的数量。")]),n._v(" "),e("p",[n._v("岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。")]),n._v(" "),e("p",[n._v("此外，你可以假设该网格的四条边均被水包围。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：grid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\n输出：1\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n输出：3\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("m == grid.length")])]),n._v(" "),e("li",[e("code",[n._v("n == grid[i].length")])]),n._v(" "),e("li",[e("code",[n._v("1 <= m, n <= 300")])]),n._v(" "),e("li",[e("code",[n._v("grid[i][j]")]),n._v(" 的值为 "),e("code",[n._v("'0'")]),n._v(" 或 "),e("code",[n._v("'1'")])])]),n._v(" "),e("p",[e("strong",[n._v("1.深度优先遍历&沉没法")])]),n._v(" "),e("p",[n._v("直接遍历这个二维矩阵，每碰到一个“1”，就通过深度优先的方式一直“沉没”它以及它周围的“1”，这样每次dfs之后都能沉没一整个岛屿，每沉没一个岛屿就计数+1，沉没的岛屿总数就是总的岛屿数量，时间复杂度O(m*n)，空间复杂度O(m*n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function (grid) {\n    let dfs = (i, j) => {\n        if (\n            i < 0 ||\n            i >= grid.length ||\n            j < 0 ||\n            j >= grid[0].length ||\n            grid[i][j] === "0"\n        )\n            return;\n        grid[i][j] = "0";\n        dfs(i - 1, j);\n        dfs(i + 1, j);\n        dfs(i, j - 1);\n        dfs(i, j + 1);\n    };\n\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === "1") {\n                dfs(i, j);\n                count++;\n            }\n        }\n    }\n    return count;\n};\n')])])]),e("h2",{attrs:{id:"_129-求根节点到叶节点数字之和"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_129-求根节点到叶节点数字之和"}},[n._v("#")]),n._v(" 129.求根节点到叶节点数字之和")]),n._v(" "),e("p",[n._v("给你一个二叉树的根节点 "),e("code",[n._v("root")]),n._v(" ，树中每个节点都存放有一个 "),e("code",[n._v("0")]),n._v(" 到 "),e("code",[n._v("9")]),n._v(" 之间的数字。")]),n._v(" "),e("p",[n._v("每条从根节点到叶节点的路径都代表一个数字：")]),n._v(" "),e("ul",[e("li",[n._v("例如，从根节点到叶节点的路径 "),e("code",[n._v("1 -> 2 -> 3")]),n._v(" 表示数字 "),e("code",[n._v("123")]),n._v(" 。")])]),n._v(" "),e("p",[n._v("计算从根节点到叶节点生成的 "),e("strong",[n._v("所有数字之和")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("叶节点")]),n._v(" 是指没有子节点的节点。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,2,3]\n输出：25\n解释：\n从根到叶子节点路径 1->2 代表数字 12\n从根到叶子节点路径 1->3 代表数字 13\n因此，数字总和 = 12 + 13 = 25\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4->9->5 代表数字 495\n从根到叶子节点路径 4->9->1 代表数字 491\n从根到叶子节点路径 4->0 代表数字 40\n因此，数字总和 = 495 + 491 + 40 = 1026\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点的数目在范围 "),e("code",[n._v("[1, 1000]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("0 <= Node.val <= 9")])]),n._v(" "),e("li",[n._v("树的深度不超过 "),e("code",[n._v("10")])])]),n._v(" "),e("p",[e("strong",[n._v("1.dfs")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)，空间复杂度O(h)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n    let sum = 0;\n    let dfs = (root, num) => {\n        num = num * 10 + root.val;\n        if (!root.left && !root.right) {\n            sum += num;\n        }\n        if (root.left) dfs(root.left, num);\n        if (root.right) dfs(root.right, num);\n\n    }\n    dfs(root, 0);\n    return sum;\n};\n")])])]),e("p",[e("strong",[n._v("2.bfs")])]),n._v(" "),e("p",[n._v("采用层序遍历的方式，但是要多维护一个numQueue数组来存储临时的数值，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function (root) {\n    let sum = 0;\n    let queue = [root];\n    let numQueue = [root.val];\n    while (queue.length) {\n        let size = queue.length;\n        for (let i = 0; i < size; i++) {\n            let cur = queue.shift();\n            let curNum = numQueue.shift();\n            if (!cur.left && !cur.right) sum += curNum;\n            if (cur.left) {\n                queue.push(cur.left);\n                numQueue.push(curNum * 10 + cur.left.val);\n            }\n            if (cur.right) {\n                queue.push(cur.right);\n                numQueue.push(curNum * 10 + cur.right.val);\n            }\n        }\n    }\n    return sum;\n};\n")])])]),e("h2",{attrs:{id:"_704-二分查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_704-二分查找"}},[n._v("#")]),n._v(" 704.二分查找")]),n._v(" "),e("p",[n._v("给定一个 "),e("code",[n._v("n")]),n._v(" 个元素有序的（升序）整型数组 "),e("code",[n._v("nums")]),n._v(" 和一个目标值 "),e("code",[n._v("target")]),n._v(" ，写一个函数搜索 "),e("code",[n._v("nums")]),n._v(" 中的 "),e("code",[n._v("target")]),n._v("，如果目标值存在返回下标，否则返回 "),e("code",[n._v("-1")]),n._v("。\n"),e("strong",[n._v("示例 1:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n")])])]),e("p",[e("strong",[n._v("示例 2:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ol",[e("li",[n._v("你可以假设 "),e("code",[n._v("nums")]),n._v(" 中的所有元素是不重复的。")]),n._v(" "),e("li",[e("code",[n._v("n")]),n._v(" 将在 "),e("code",[n._v("[1, 10000]")]),n._v("之间。")]),n._v(" "),e("li",[e("code",[n._v("nums")]),n._v(" 的每个元素都将在 "),e("code",[n._v("[-9999, 9999]")]),n._v("之间。")])]),n._v(" "),e("p",[e("strong",[n._v("1.二分查找")])]),n._v(" "),e("p",[n._v("时间复杂度O(logn)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] < target) left = mid + 1;\n        else if (nums[mid] > target) right = mid - 1;\n        else return mid;\n    }\n    return -1;\n};\n")])])]),e("h2",{attrs:{id:"_300-最长递增子序列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_300-最长递增子序列"}},[n._v("#")]),n._v(" 300.最长递增子序列")]),n._v(" "),e("p",[n._v("给你一个整数数组 "),e("code",[n._v("nums")]),n._v(" ，找到其中最长严格递增子序列的长度。")]),n._v(" "),e("p",[e("strong",[n._v("子序列")]),n._v(" 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，"),e("code",[n._v("[3,6,2,7]")]),n._v(" 是数组 "),e("code",[n._v("[0,3,1,6,2,2,7]")]),n._v(" 的子序列。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [0,1,0,3,2,3]\n输出：4\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：nums = [7,7,7,7,7,7,7]\n输出：1\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= nums.length <= 2500")])]),n._v(" "),e("li",[e("code",[n._v("-104 <= nums[i] <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")])]),n._v(" "),e("ul",[e("li",[n._v("你能将算法的时间复杂度降低到 "),e("code",[n._v("O(nlog(n))")]),n._v(" 吗?")])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("dp[i]的含义是以i结尾的最长严格递增子序列的长度，这里i要与之前的每个j比较，可以视为能否从这个j跳到i，如果可以，则dp[i] = Math.max(dp[i], dp[j] + 1)，之所以还要与dp[i]比较，是因为dp[i]在不断变化，只有比之前最大的dp[i]大，才需要更新，时间复杂度O(n^2)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function (nums) {\n    let dp = new Array(nums.length).fill(1);\n    let result = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n                result = Math.max(result, dp[i]);\n            }\n        }\n    }\n    return result;\n};\n")])])]),e("p",[e("strong",[n._v("2贪心+二分法")])]),n._v(" "),e("p",[n._v("维护一个最小递增子序列数组tails，始终选择当前能够构成的最小递增子序列的尾部元素，以便未来有更大的扩展空间，每次遇到新的nums[i]时，如果nums[i]大于tails里所有元素，就追加到tails末尾，如果nums[i]可以替换tails中某个元素（使用二分查找找到第一个≥nums[i]的位置），我们进行替换，以保持tails递增但尽量小，时间复杂度O(nlogn)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function (nums) {\n    let tails = [];\n    for (let i = 0; i < nums.length; i++) {\n        let left = 0;\n        let right = tails.length - 1;\n        while (left <= right) {\n            let mid = Math.floor(left + (right - left) / 2);\n            if (tails[mid] < nums[i]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1; // 继续寻找第一个>=nums[i]的位置\n            }\n        }\n        if (left <= tails.length - 1) tails[left] = nums[i];\n        else tails.push(nums[i]);\n    }\n    return tails.length;\n};\n")])])]),e("h2",{attrs:{id:"_322-零钱兑换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_322-零钱兑换"}},[n._v("#")]),n._v(" 322.零钱兑换")]),n._v(" "),e("p",[n._v("给你一个整数数组 "),e("code",[n._v("coins")]),n._v(" ，表示不同面额的硬币；以及一个整数 "),e("code",[n._v("amount")]),n._v(" ，表示总金额。")]),n._v(" "),e("p",[n._v("计算并返回可以凑成总金额所需的 "),e("strong",[n._v("最少的硬币个数")]),n._v(" 。如果没有任何一种硬币组合能组成总金额，返回 "),e("code",[n._v("-1")]),n._v(" 。")]),n._v(" "),e("p",[n._v("你可以认为每种硬币的数量是无限的。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：coins = [1, 2, 5], amount = 11\n输出：3 \n解释：11 = 5 + 5 + 1\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：coins = [2], amount = 3\n输出：-1\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：coins = [1], amount = 0\n输出：0\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= coins.length <= 12")])]),n._v(" "),e("li",[e("code",[n._v("1 <= coins[i] <= 231 - 1")])]),n._v(" "),e("li",[e("code",[n._v("0 <= amount <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("dp[j]表示总金额为j时需要的最少硬币数，dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j])，此处+1是为了补上减掉的coins[i]这个硬币，加上的是硬币数，所以是1，时间复杂度O(n*m)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function (coins, amount) {\n    let dp = Array(amount + 1).fill(Number.MAX_SAFE_INTEGER);\n    dp[0] = 0;\n    for (let i = 0; i < coins.length; i++) {\n        for (let j = coins[i]; j <= amount; j++) {\n            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);\n        }\n    }\n    return dp[amount] === Number.MAX_SAFE_INTEGER ? -1 : dp[amount];\n};\n")])])]),e("h2",{attrs:{id:"_93-复原ip地址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_93-复原ip地址"}},[n._v("#")]),n._v(" 93.复原IP地址")]),n._v(" "),e("p",[e("strong",[n._v("有效 IP 地址")]),n._v(" 正好由四个整数（每个整数位于 "),e("code",[n._v("0")]),n._v(" 到 "),e("code",[n._v("255")]),n._v(" 之间组成，且不能含有前导 "),e("code",[n._v("0")]),n._v("），整数之间用 "),e("code",[n._v("'.'")]),n._v(" 分隔。")]),n._v(" "),e("ul",[e("li",[n._v("例如："),e("code",[n._v('"0.1.2.201"')]),n._v(" 和"),e("code",[n._v('"192.168.1.1"')]),n._v(" 是 "),e("strong",[n._v("有效")]),n._v(" IP 地址，但是 "),e("code",[n._v('"0.011.255.245"')]),n._v("、"),e("code",[n._v('"192.168.1.312"')]),n._v(" 和 "),e("code",[n._v('"192.168@1.1"')]),n._v(" 是 "),e("strong",[n._v("无效")]),n._v(" IP 地址。")])]),n._v(" "),e("p",[n._v("给定一个只包含数字的字符串 "),e("code",[n._v("s")]),n._v(" ，用以表示一个 IP 地址，返回所有可能的"),e("strong",[n._v("有效 IP 地址")]),n._v("，这些地址可以通过在 "),e("code",[n._v("s")]),n._v(" 中插入 "),e("code",[n._v("'.'")]),n._v(" 来形成。你 "),e("strong",[n._v("不能")]),n._v(" 重新排序或删除 "),e("code",[n._v("s")]),n._v(" 中的任何数字。你可以按 "),e("strong",[n._v("任何")]),n._v(" 顺序返回答案。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：s = "25525511135"\n输出：["255.255.11.135","255.255.111.35"]\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：s = "0000"\n输出：["0.0.0.0"]\n')])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：s = "101023"\n输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= s.length <= 20")])]),n._v(" "),e("li",[e("code",[n._v("s")]),n._v(" 仅由数字组成")])]),n._v(" "),e("p",[e("strong",[n._v("1.回溯法")])]),n._v(" "),e("p",[n._v("遍历字符串的同时往字符串中插入分隔符“.”，每分隔完一次就进行递归，并判断是否合法，递归结束则通过回溯寻找更多可能性，时间复杂度O(n^3)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function (s) {\n    let result = [];\n    let backTracking = (s, startIndex, pointNums) => {\n        if (pointNums === 3) {\n            if (isValid(s, startIndex, s.length - 1)) {\n                result.push(s);\n            }\n            return;\n        }\n        for (let i = startIndex; i < s.length; i++) {\n            if (isValid(s, startIndex, i)) {\n                s = s.slice(0, i + 1) + "." + s.slice(i + 1);\n                pointNums++;\n                backTracking(s, i + 2, pointNums);\n                s = s.slice(0, i + 1) + s.slice(i + 2);\n                pointNums--;\n            }\n        }\n    };\n    let isValid = (s, startIndex, endIndex) => {\n        let str = s.substring(startIndex, endIndex + 1);\n        if (\n            (str.length > 1 && str[0] === "0") ||\n            str.length > 3 || str.length === 0 ||\n            parseInt(str) > 255\n        )\n            return false;\n        return true;\n    };\n\n    backTracking(s, 0, 0);\n    return result;\n};\n')])])]),e("h2",{attrs:{id:"_22-括号生成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-括号生成"}},[n._v("#")]),n._v(" 22.括号生成")]),n._v(" "),e("p",[n._v("数字 "),e("code",[n._v("n")]),n._v(" 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 "),e("strong",[n._v("有效的")]),n._v(" 括号组合。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 3\n输出：["((()))","(()())","(())()","()(())","()()()"]\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 1\n输出：["()"]\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= n <= 8")])])]),n._v(" "),e("p",[e("strong",[n._v("1.回溯法")])]),n._v(" "),e("p",[n._v("只有当左括号数量小于等于右括号数量的时候才是合法的，时间复杂度O(2^n)，空间复杂度O(2^n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function (n) {\n    let result = [];\n    let s = "(";\n    let backTracking = (s, left, right) => {\n        if (left < right) return;\n        if (left === n && right === n) {\n            result.push(s);\n            return;\n        }\n        if (left < n) {\n            s += "(";\n            backTracking(s, left + 1, right);\n            s = s.slice(0, -1);\n        }\n        if (right < n) {\n            s += ")";\n            backTracking(s, left, right + 1);\n            s = s.slice(0, -1);\n        }\n    };\n    backTracking(s, 1, 0);\n    return result;\n};\n')])])]),e("h2",{attrs:{id:"_94-二叉树的中序遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_94-二叉树的中序遍历"}},[n._v("#")]),n._v(" 94.二叉树的中序遍历")]),n._v(" "),e("p",[n._v("给定一个二叉树的根节点 "),e("code",[n._v("root")]),n._v(" ，返回 "),e("em",[n._v("它的 "),e("strong",[n._v("中序")]),n._v(" 遍历")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,null,2,3]\n输出：[1,3,2]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1]\n输出：[1]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点数目在范围 "),e("code",[n._v("[0, 100]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("-100 <= Node.val <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶:")]),n._v(" 递归算法很简单，你可以通过迭代算法完成吗？")]),n._v(" "),e("p",[e("strong",[n._v("1.递归法")])]),n._v(" "),e("p",[n._v("二叉树的前中后序遍历，其递归写法都很类似，前序根左右，中序左根右，后序左右根，只需要在循环中按以上顺序递归，并在访问到根时将数据压入数组即可，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n    let result = [];\n    let traversal = (root) => {\n        if (root) {\n            traversal(root.left);\n            result.push(root.val);\n            traversal(root.right);\n        }\n    }\n    traversal(root);\n    return result;\n};\n")])])]),e("p",[e("strong",[n._v("2.迭代法（非递归）")])]),n._v(" "),e("p",[n._v("用栈来记录遍历的顺序，用result存储结果，如果当前节点存在，就一直往左走，如果不存在，则弹出栈顶元素，并加入result中，然后往右节点走，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function (root) {\n    let result = [];\n    let stack = [];\n    while(root || stack.length !== 0) {\n        if(root) {\n            stack.push(root);\n            root = root.left;\n        } else {\n            root = stack.pop();\n            result.push(root.val);\n            root = root.right;\n        }\n    }\n    return result;\n};\n")])])]),e("h2",{attrs:{id:"_104-二叉树的最大深度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_104-二叉树的最大深度"}},[n._v("#")]),n._v(" 104.二叉树的最大深度")]),n._v(" "),e("p",[n._v("给定一个二叉树 "),e("code",[n._v("root")]),n._v(" ，返回其最大深度。")]),n._v(" "),e("p",[n._v("二叉树的 "),e("strong",[n._v("最大深度")]),n._v(" 是指从根节点到最远叶子节点的最长路径上的节点数。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,9,20,null,null,15,7]\n输出：3\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,null,2]\n输出：2\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点的数量在 "),e("code",[n._v("[0, 104]")]),n._v(" 区间内。")]),n._v(" "),e("li",[e("code",[n._v("-100 <= Node.val <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("1.dfs")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)，空间复杂度O(h)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function (root) {\n    let maxDepth = 0;\n    let dfs = (root, depth) => {\n        if (!root) return;\n        depth++;\n        if (maxDepth < depth) maxDepth = depth;\n        if (root.left) dfs(root.left, depth);\n        if (root.right) dfs(root.right, depth);\n    }\n    dfs(root, 0);\n    return maxDepth;\n};\n")])])]),e("h2",{attrs:{id:"lcr-140-训练计划-ii"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lcr-140-训练计划-ii"}},[n._v("#")]),n._v(" LCR 140. 训练计划 II")]),n._v(" "),e("p",[n._v("给定一个头节点为 "),e("code",[n._v("head")]),n._v(" 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 "),e("code",[n._v("cnt")]),n._v(" 个训练项目编号。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：head = [2,4,7,8], cnt = 1\n输出：8\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= head.length <= 100")])]),n._v(" "),e("li",[e("code",[n._v("0 <= head[i] <= 100")])]),n._v(" "),e("li",[e("code",[n._v("1 <= cnt <= head.length")])])]),n._v(" "),e("p",[n._v("1.快慢指针")]),n._v(" "),e("p",[n._v("只需遍历一次，快指针先走cnt步，然后和慢指针一起每次走一步，当快指针为空时，慢指针指向的就是所求，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} cnt\n * @return {ListNode}\n */\nvar trainingPlan = function (head, cnt) {\n    let fast = head;\n    let slow = head;\n    for (let i = 0; i < cnt; i++) fast = fast.next;\n    while (fast) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return slow;\n};\n")])])]),e("h2",{attrs:{id:"_62-不同路径"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_62-不同路径"}},[n._v("#")]),n._v(" 62.不同路径")]),n._v(" "),e("p",[n._v("一个机器人位于一个 "),e("code",[n._v("m x n")]),n._v(" 网格的左上角 （起始点在下图中标记为 “Start” ）。")]),n._v(" "),e("p",[n._v("机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。")]),n._v(" "),e("p",[n._v("问总共有多少条不同的路径？")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://pic.leetcode.cn/1697422740-adxmsI-image.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：m = 3, n = 7\n输出：28\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：m = 7, n = 3\n输出：28\n")])])]),e("p",[e("strong",[n._v("示例 4：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：m = 3, n = 3\n输出：6\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= m, n <= 100")])]),n._v(" "),e("li",[n._v("题目数据保证答案小于等于 "),e("code",[n._v("2 * 10^9")])])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("维护一个m*n的二维数组dp，dp[i][j]代表到第i+1行，第j+1列一共有多少种路径，等于到其上方的路径与到其左方的路径之和，时间复杂度O(m*n)，空间复杂度O(m*n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function (m, n) {\n    let dp = Array(m).fill().map(() => Array(n));\n    for (let i = 0; i < m; i++) dp[i][0] = 1;\n    for (let i = 0; i < n; i++) dp[0][i] = 1\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n};\n")])])]),e("h2",{attrs:{id:"_695-岛屿的最大面积"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_695-岛屿的最大面积"}},[n._v("#")]),n._v(" 695.岛屿的最大面积")]),n._v(" "),e("p",[n._v("给你一个大小为 "),e("code",[n._v("m x n")]),n._v(" 的二进制矩阵 "),e("code",[n._v("grid")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("岛屿")]),n._v(" 是由一些相邻的 "),e("code",[n._v("1")]),n._v(" (代表土地) 构成的组合，这里的「相邻」要求两个 "),e("code",[n._v("1")]),n._v(" 必须在 "),e("strong",[n._v("水平或者竖直的四个方向上")]),n._v(" 相邻。你可以假设 "),e("code",[n._v("grid")]),n._v(" 的四个边缘都被 "),e("code",[n._v("0")]),n._v("（代表水）包围着。")]),n._v(" "),e("p",[n._v("岛屿的面积是岛上值为 "),e("code",[n._v("1")]),n._v(" 的单元格的数目。")]),n._v(" "),e("p",[n._v("计算并返回 "),e("code",[n._v("grid")]),n._v(" 中最大的岛屿面积。如果没有岛屿，则返回面积为 "),e("code",[n._v("0")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出：6\n解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：grid = [[0,0,0,0,0,0,0,0]]\n输出：0\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("m == grid.length")])]),n._v(" "),e("li",[e("code",[n._v("n == grid[i].length")])]),n._v(" "),e("li",[e("code",[n._v("1 <= m, n <= 50")])]),n._v(" "),e("li",[e("code",[n._v("grid[i][j]")]),n._v(" 为 "),e("code",[n._v("0")]),n._v(" 或 "),e("code",[n._v("1")])])]),n._v(" "),e("p",[e("strong",[n._v("1.深度优先遍历&沉没法")])]),n._v(" "),e("p",[n._v("在岛屿数量这题的基础上新增一个面积变量，每次沉没岛屿的时候+1即可，时间复杂度O(m*n)，空间复杂度O(m*n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function (grid) {\n    let maxArea = 0;\n    let area = 0;\n    let dfs = (i, j) => {\n        if (\n            i < 0 ||\n            i >= grid.length ||\n            j < 0 ||\n            j >= grid[0].length ||\n            grid[i][j] === 0\n        )\n            return;\n        grid[i][j] = 0;\n        area++;\n        if (area > maxArea) maxArea = area;\n        dfs(i - 1, j);\n        dfs(i + 1, j);\n        dfs(i, j - 1);\n        dfs(i, j + 1);\n    };\n\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                dfs(i, j, 0);\n                area = 0;\n            }\n        }\n    }\n    return maxArea;\n};\n")])])]),e("h2",{attrs:{id:"lcr-126-斐波那契数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lcr-126-斐波那契数"}},[n._v("#")]),n._v(" LCR 126. 斐波那契数")]),n._v(" "),e("p",[e("strong",[n._v("斐波那契数")]),n._v(" （通常用 "),e("code",[n._v("F(n)")]),n._v(" 表示）形成的序列称为 "),e("strong",[n._v("斐波那契数列")]),n._v(" 。该数列由 "),e("strong",[n._v("0")]),n._v(" 和 "),e("strong",[n._v("1")]),n._v(" 开始，后面的每一项数字都是前面两项数字的和。也就是：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("F(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n")])])]),e("p",[n._v("给定 "),e("code",[n._v("n")]),n._v(" ，请计算 "),e("code",[n._v("F(n)")]),n._v(" 。")]),n._v(" "),e("p",[n._v("答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：n = 2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：n = 3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：n = 4\n输出：3\n解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("0 <= n <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("1.动态规划")])]),n._v(" "),e("p",[n._v("此题取模是为了把数值控制在可控范围内，防止溢出，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function (n) {\n    if (n === 0) return 0;\n    if (n === 1) return 1;\n    let dp = [0, 1];\n    for (let i = 2; i <= n; i++) {\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\n    }\n    return dp[dp.length - 1];\n};\n")])])]),e("h2",{attrs:{id:"_42-接雨水"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_42-接雨水"}},[n._v("#")]),n._v(" 42.接雨水")]),n._v(" "),e("p",[n._v("给定 "),e("code",[n._v("n")]),n._v(" 个非负整数表示每个宽度为 "),e("code",[n._v("1")]),n._v(" 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：height = [4,2,0,3,2,5]\n输出：9\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("n == height.length")])]),n._v(" "),e("li",[e("code",[n._v("1 <= n <= 2 * 10^4")])]),n._v(" "),e("li",[e("code",[n._v("0 <= height[i] <= 10^5")])])]),n._v(" "),e("p",[e("strong",[n._v("1.前后缀分解")])]),n._v(" "),e("p",[n._v("维护一个前缀最大值数组，代表第i个位置之前最大的高度是多少，也就是左侧最大高度，再维护一个后缀最大值数组，代表第i个位置之后最大的高度是多少，也就是右侧最大高度，这两个高度的最小值就代表所能容纳的最大雨水量，减去第i个位置本身的高度，就是第i个位置实际所能容纳的雨水量，将所有位置累加就是答案，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function (height) {\n    let area = 0;\n    let leftMax = Array(height.length).fill(0);\n    let rightMax = Array(height.length).fill(0);\n    leftMax[0] = height[0];\n    rightMax[height.length - 1] = height[height.length - 1];\n    for (let i = 1; i < height.length; i++) {\n        leftMax[i] = Math.max(leftMax[i - 1], height[i]);\n    }\n    for (let i = height.length - 2; i >= 0; i--) {\n        rightMax[i] = Math.max(rightMax[i + 1], height[i]);\n    }\n    for (let i = 0; i < height.length; i++) {\n        area += Math.min(leftMax[i], rightMax[i]) - height[i];\n    }\n    return area;\n};\n")])])]),e("p",[e("strong",[n._v("2.相向双指针法")])]),n._v(" "),e("p",[n._v("思路其实和第一种方法类似，但是这里不需要用数组存储前后缀最大值，因为比如当前缀最大值小于后缀最大值时，所能存储的最大容量就是前缀最大值减去当前的高度了，注意while循环内不需要判断left===right的情况，因为这种情况下两者重合面积为0，而最后一块需要计算的面积在此之前已经计算过了，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function (height) {\n    let area = 0;\n    let left = 0;\n    let right = height.length - 1;\n    let leftMax = 0;\n    let rightMax = 0;\n    while (left < right) {\n        leftMax = Math.max(leftMax, height[left]);\n        rightMax = Math.max(rightMax, height[right]);\n        if (leftMax < rightMax) {\n            area += leftMax - height[left];\n            left++;\n        } else {\n            area += rightMax - height[right];\n            right--;\n        }\n    }\n    return area;\n};\n")])])]),e("h2",{attrs:{id:"_56-合并区间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_56-合并区间"}},[n._v("#")]),n._v(" 56.合并区间")]),n._v(" "),e("p",[n._v("以数组 "),e("code",[n._v("intervals")]),n._v(" 表示若干个区间的集合，其中单个区间为 "),e("code",[n._v("intervals[i] = [starti, endi]")]),n._v(" 。请你合并所有重叠的区间，并返回 "),e("em",[n._v("一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= intervals.length <= 10^4")])]),n._v(" "),e("li",[e("code",[n._v("intervals[i].length == 2")])]),n._v(" "),e("li",[e("code",[n._v("0 <= starti <= endi <= 10^4")])])]),n._v(" "),e("p",[e("strong",[n._v("1.排序法")])]),n._v(" "),e("p",[n._v("先排序后比较大小，注意前一元素与后一元素的首元素和尾元素比较时要分情况，若大于其尾元素则前一元素不需要改变，时间复杂度O(nlogn)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function (intervals) {\n    intervals.sort((a, b) => {\n        return a[0] - b[0];\n    });\n    for (let i = 0; i < intervals.length - 1; i++) {\n        if (intervals[i][1] >= intervals[i + 1][0]) {\n            if (intervals[i][1] < intervals[i + 1][1])\n                intervals[i][1] = intervals[i + 1][1];\n            intervals.splice(i + 1, 1);\n            i--;\n        }\n    }\n    return intervals;\n};\n")])])]),e("h2",{attrs:{id:"_236-二叉树的最近公共祖先"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_236-二叉树的最近公共祖先"}},[n._v("#")]),n._v(" 236.二叉树的最近公共祖先")]),n._v(" "),e("p",[n._v("给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。")]),n._v(" "),e("p",[e("a",{attrs:{href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[n._v("百度百科"),e("OutboundLink")],1),n._v("中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),e("strong",[n._v("一个节点也可以是它自己的祖先")]),n._v("）。”")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1,2], p = 1, q = 2\n输出：1\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点数目在范围 "),e("code",[n._v("[2, 105]")]),n._v(" 内。")]),n._v(" "),e("li",[e("code",[n._v("-109 <= Node.val <= 109")])]),n._v(" "),e("li",[n._v("所有 "),e("code",[n._v("Node.val")]),n._v(" "),e("code",[n._v("互不相同")]),n._v(" 。")]),n._v(" "),e("li",[e("code",[n._v("p != q")])]),n._v(" "),e("li",[e("code",[n._v("p")]),n._v(" 和 "),e("code",[n._v("q")]),n._v(" 均存在于给定的二叉树中。")])]),n._v(" "),e("p",[e("strong",[n._v("1.后序遍历法")])]),n._v(" "),e("p",[n._v("通过后序遍历，若存在p或q则不断向上返回左右孩子，时间复杂度O(n)，空间复杂度O(h)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n    let traversal = (root, p, q) => {\n        if (root === null) return root;\n        if (root === p || root === q) return root;\n        let left = traversal(root.left, p, q);\n        let right = traversal(root.right, p, q);\n        if (left !== null && right !== null) return root;\n        if (left === null && right !== null) return right;\n        else if (left !== null && right === null) return left;\n        else return null;\n    }\n    return traversal(root, p, q);\n};\n")])])]),e("h2",{attrs:{id:"_103-二叉树的锯齿形层序遍历"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_103-二叉树的锯齿形层序遍历"}},[n._v("#")]),n._v(" 103.二叉树的锯齿形层序遍历")]),n._v(" "),e("p",[n._v("给你二叉树的根节点 "),e("code",[n._v("root")]),n._v(" ，返回其节点值的 "),e("strong",[n._v("锯齿形层序遍历")]),n._v(" 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [3,9,20,null,null,15,7]\n输出：[[3],[20,9],[15,7]]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [1]\n输出：[[1]]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点数目在范围 "),e("code",[n._v("[0, 2000]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("-100 <= Node.val <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("1.层序遍历")])]),n._v(" "),e("p",[n._v("层序遍历每偶数层翻转subRes数组即可，时间复杂度O(n^2)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function (root) {\n    if (!root) return [];\n    let result = [];\n    let queue = [root];\n    let k = 0;\n    while(queue.length) {\n        let length = queue.length;\n        let subRes = [];\n        k++;\n        while(length--) {\n            let cur = queue.shift();\n            subRes.push(cur.val);\n            if(cur.left) queue.push(cur.left);\n            if(cur.right) queue.push(cur.right);\n        }\n        if(k % 2 === 0) subRes.reverse();\n        result.push(subRes);\n    }\n    return result;\n};\n")])])]),e("h2",{attrs:{id:"_2-两数相加"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-两数相加"}},[n._v("#")]),n._v(" 2.两数相加")]),n._v(" "),e("p",[n._v("给你两个 "),e("strong",[n._v("非空")]),n._v(" 的链表，表示两个非负的整数。它们每位数字都是按照 "),e("strong",[n._v("逆序")]),n._v(" 的方式存储的，并且每个节点只能存储 "),e("strong",[n._v("一位")]),n._v(" 数字。")]),n._v(" "),e("p",[n._v("请你将两个数相加，并以相同形式返回一个表示和的链表。")]),n._v(" "),e("p",[n._v("你可以假设除了数字 0 之外，这两个数都不会以 0 开头。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [0], l2 = [0]\n输出：[0]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("每个链表中的节点数在范围 "),e("code",[n._v("[1, 100]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("0 <= Node.val <= 9")])]),n._v(" "),e("li",[n._v("题目数据保证列表表示的数字不含前导零")])]),n._v(" "),e("p",[e("strong",[n._v("1.按位求和法")])]),n._v(" "),e("p",[n._v("利用数字按位求和的方法，直接遍历按位求和即可，注意求和过程要考虑进位，时间复杂度O(Max(m,n))，空间复杂度O(Max(m,n))：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n    let head = new ListNode(0, null);\n    let cur = head;\n    let carry = 0;\n    while (l1 && l2) {\n        let sum = l1.val + l2.val + carry;\n        carry = 0;\n        if (sum >= 10) {\n            sum -= 10;\n            carry = 1;\n        }\n        cur.next = new ListNode(sum, null);\n        cur = cur.next;\n        l1 = l1.next;\n        l2 = l2.next;\n    }\n    while (l1) {\n        sum = l1.val + carry;\n        carry = 0;\n        if (sum >= 10) {\n            sum -= 10;\n            carry = 1;\n        }\n        cur.next = new ListNode(sum, null);\n        cur = cur.next;\n        l1 = l1.next;\n    }\n    while (l2) {\n        sum = l2.val + carry;\n        carry = 0;\n        if (sum >= 10) {\n            sum -= 10;\n            carry = 1;\n        }\n        cur.next = new ListNode(sum, null);\n        cur = cur.next;\n        l2 = l2.next;\n    }\n    if (!l1 && !l2 && carry)\n        cur.next = new ListNode(carry, null);\n    return head.next;\n};\n")])])]),e("h2",{attrs:{id:"_1556-千位分隔数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1556-千位分隔数"}},[n._v("#")]),n._v(" 1556.千位分隔数")]),n._v(" "),e("p",[n._v("给你一个整数 "),e("code",[n._v("n")]),n._v('，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回。')]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 987\n输出："987"\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 1234\n输出："1.234"\n')])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 123456789\n输出："123.456.789"\n')])])]),e("p",[e("strong",[n._v("示例 4：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：n = 0\n输出："0"\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("0 <= n < 2^31")])])]),n._v(" "),e("p",[e("strong",[n._v("1.toLocaleString")])]),n._v(" "),e("p",[n._v("时间复杂度O(1)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {number} n\n * @return {string}\n */\nvar thousandSeparator = function (n) {\n    return n.toLocaleString().replace(/,/g, ".");\n};\n')])])]),e("p",[e("strong",[n._v("2.splice+join")])]),n._v(" "),e("p",[n._v("时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('/**\n * @param {number} n\n * @return {string}\n */\nvar thousandSeparator = function (n) {\n    let str = n.toString().split("");\n    for (let i = str.length - 3; i > 0; i = i - 3) {\n        str.splice(i, 0, ".");\n    }\n    return str.join(\'\');\n};\n')])])]),e("h2",{attrs:{id:"_209-长度最小的子数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_209-长度最小的子数组"}},[n._v("#")]),n._v(" 209.长度最小的子数组")]),n._v(" "),e("p",[n._v("给定一个含有 "),e("code",[n._v("n")]),n._v(" 个正整数的数组和一个正整数 "),e("code",[n._v("target")]),n._v(" "),e("strong",[n._v("。")])]),n._v(" "),e("p",[n._v("找出该数组中满足其总和大于等于 "),e("code",[n._v("target")]),n._v(" 的长度最小的 "),e("strong",[n._v("子数组")]),n._v(" "),e("code",[n._v("[numsl, numsl+1, ..., numsr-1, numsr]")]),n._v(" ，并返回其长度**。**如果不存在符合条件的子数组，返回 "),e("code",[n._v("0")]),n._v(" 。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：target = 4, nums = [1,4,4]\n输出：1\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= target <= 109")])]),n._v(" "),e("li",[e("code",[n._v("1 <= nums.length <= 105")])]),n._v(" "),e("li",[e("code",[n._v("1 <= nums[i] <= 104")])])]),n._v(" "),e("p",[e("strong",[n._v("进阶：")])]),n._v(" "),e("ul",[e("li",[n._v("如果你已经实现 "),e("code",[n._v("O(n)")]),n._v(" 时间复杂度的解法, 请尝试设计一个 "),e("code",[n._v("O(n log(n))")]),n._v(" 时间复杂度的解法。")])]),n._v(" "),e("p",[e("strong",[n._v("1.滑动窗口解法（双指针）")])]),n._v(" "),e("p",[n._v("做法与无重复字符的最长子串类似，先找到大于等于target的子数组，然后右指针不动，移动左指针去寻找更短的子数组，若没有找到，再移动右指针，寻找更多可能，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\nvar minSubArrayLen = function (target, nums) {\n    let left = 0;\n    let right = 0;\n    let sum = 0;\n    let minLength = nums.length + 1;\n    while (right !== nums.length) {\n        sum += nums[right];\n        while (sum >= target) {\n            right - left + 1 < minLength ? minLength = right - left + 1 : minLength;\n            sum -= nums[left];\n            left++;\n        }\n        right++;\n    }\n    return minLength === nums.length + 1 ? 0 : minLength;\n};\n")])])]),e("h2",{attrs:{id:"_283-移动零"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_283-移动零"}},[n._v("#")]),n._v(" 283.移动零")]),n._v(" "),e("p",[n._v("给定一个数组 "),e("code",[n._v("nums")]),n._v("，编写一个函数将所有 "),e("code",[n._v("0")]),n._v(" 移动到数组的末尾，同时保持非零元素的相对顺序。")]),n._v(" "),e("p",[e("strong",[n._v("请注意")]),n._v(" ，必须在不复制数组的情况下原地对数组进行操作。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n")])])]),e("p",[e("strong",[n._v("示例 2:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入: nums = [0]\n输出: [0]\n")])])]),e("p",[e("strong",[n._v("提示")]),n._v(":")]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= nums.length <= 10^4")])]),n._v(" "),e("li",[e("code",[n._v("-2^31 <= nums[i] <= 2^31 - 1")])])]),n._v(" "),e("p",[n._v("**进阶：**你能尽量减少完成的操作次数吗？")]),n._v(" "),e("p",[e("strong",[n._v("1.双指针法")])]),n._v(" "),e("p",[n._v("一个指针去按序遍历数组的每一个数，当访问到非零数时，替换掉另一个指针所对应的数，最后把剩余的位置全部补零即可，此题的关键思路是把非零的数移动到数组前面，然后后面全部补零，而不是先找到零再与后面的数进行交换，时间复杂度O(n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nvar moveZeroes = function (nums) {\n    let point = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[point] = nums[i];\n            point++;\n        }\n    }\n    for (let i = point; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n    return nums;\n};\n")])])]),e("h2",{attrs:{id:"_226-翻转二叉树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_226-翻转二叉树"}},[n._v("#")]),n._v(" 226.翻转二叉树")]),n._v(" "),e("p",[n._v("给你一棵二叉树的根节点 "),e("code",[n._v("root")]),n._v(" ，翻转这棵二叉树，并返回其根节点。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [4,2,7,1,3,6,9]\n输出：[4,7,2,9,6,3,1]\n")])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg",alt:"img"}})]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = [2,1,3]\n输出：[2,3,1]\n")])])]),e("p",[e("strong",[n._v("示例 3：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("输入：root = []\n输出：[]\n")])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[n._v("树中节点数目范围在 "),e("code",[n._v("[0, 100]")]),n._v(" 内")]),n._v(" "),e("li",[e("code",[n._v("-100 <= Node.val <= 100")])])]),n._v(" "),e("p",[e("strong",[n._v("1.递归")])]),n._v(" "),e("p",[n._v("前序后序都行，中序不行（如果是中序，两次都要invertTree(root.left);不然右侧子树在交换后不会被操作到），时间复杂度O(n)，空间复杂度O(h)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n    if (!root) return root;\n    let temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n    invertTree(root.left);\n    invertTree(root.right);\n    return root;\n};\n")])])]),e("p",[e("strong",[n._v("2.层序遍历")])]),n._v(" "),e("p",[n._v("每遍历到一个节点直接交换其左右子树即可，时间复杂度O(n)，空间复杂度O(n)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function (root) {\n    if (!root) return root;\n    let queue = [root];\n    while (queue.length) {\n        let length = queue.length;\n        for (let i = 0; i < length; i++) {\n            let cur = queue.shift();\n            let temp = cur.left;\n            cur.left = cur.right;\n            cur.right = temp;\n            if (cur.left) queue.push(cur.left);\n            if (cur.right) queue.push(cur.right);\n        }\n    }\n    return root;\n};\n")])])]),e("h2",{attrs:{id:"_14-最长公共前缀"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-最长公共前缀"}},[n._v("#")]),n._v(" 14.最长公共前缀")]),n._v(" "),e("p",[n._v("编写一个函数来查找字符串数组中的最长公共前缀。")]),n._v(" "),e("p",[n._v("如果不存在公共前缀，返回空字符串 "),e("code",[n._v('""')]),n._v("。")]),n._v(" "),e("p",[e("strong",[n._v("示例 1：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：strs = ["flower","flow","flight"]\n输出："fl"\n')])])]),e("p",[e("strong",[n._v("示例 2：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('输入：strs = ["dog","racecar","car"]\n输出：""\n解释：输入不存在公共前缀。\n')])])]),e("p",[e("strong",[n._v("提示：")])]),n._v(" "),e("ul",[e("li",[e("code",[n._v("1 <= strs.length <= 200")])]),n._v(" "),e("li",[e("code",[n._v("0 <= strs[i].length <= 200")])]),n._v(" "),e("li",[e("code",[n._v("strs[i]")]),n._v(" 如果非空，则仅由小写英文字母组成")])]),n._v(" "),e("p",[e("strong",[n._v("1.纵向比较法")])]),n._v(" "),e("p",[n._v("最长公共前缀的长度肯定不会超过数组第一个元素的长度，因此比较的位数最多就是数组第一个元素的长度，每次比较都跳着去比，只比较数组每个元素当前这个位置和第一个元素这个位置是否一致，只有全部一致才会进入下一次比较，若不一致，则说明最长公共前缀就是当前位置往前一位，时间复杂度O(m*n)，空间复杂度O(1)：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("/**\n * @param {string[]} strs\n * @return {string}\n */\nvar longestCommonPrefix = function (strs) {\n    let public = strs[0];\n    for (let i = 0; i < public.length; i++) {\n        for (let j = 1; j < strs.length; j++) {\n            if (strs[j][i] !== public[i])\n                return public.slice(0, i);\n        }\n    }\n    return strs[0];\n};\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);