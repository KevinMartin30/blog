(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{594:function(n,e,t){"use strict";t.r(e);var a=t(2),r=Object(a.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[e("strong",[this._v("1.vue-responsive.html")])]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('<!DOCTYPE html>\n<html lang="en">\n  <body>\n    <div id="app">\n      <span>名称: {{name}}</span>\n      <input type="text" v-model="name" />\n      <span>工资：{{more.salary}}</span>\n      <input type="text" v-model="more.salary" />\n    </div>\n  </body>\n</html>\n\n<script src="./vue.js"><\/script>\n\n<script>\n  const vm = new Vue({\n    el: "#app",\n    data: {\n      name: "martin",\n      more: {\n        salary: 1000,\n      },\n    },\n  });\n  console.log(vm);\n<\/script>\n')])])]),e("p",[e("strong",[this._v("2.vue.js")])]),this._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('class Vue {\n  // 参数为对象实例 这个对象用于告知vue需要挂载到哪个元素并挂载数据\n  constructor(obj_instance) {\n    // 给实例赋值对象的data属性\n    this.$data = obj_instance.data;\n    // 进行数据劫持 监听对象里属性的变化\n    Observer(this.$data);\n    Complie(obj_instance.el, this);\n  }\n}\n\n//数据劫持 —— 监听实例里的数据\nfunction Observer(data_instance) {\n  // 递归出口\n  if (!data_instance || typeof data_instance !== "object") return;\n  // 每次数据劫持一个对象时都创建Dependency实例 用于区分哪个对象对应哪个依赖实例和收集依赖\n  const dependency = new Dependency();\n  Object.keys(data_instance).forEach((key) => {\n    // 使用defineProperty后属性里的值会被修改 需要提前保存属性的值\n    let value = data_instance[key];\n    // 递归劫持data里的子属性\n    Observer(value);\n    Object.defineProperty(data_instance, key, {\n      enumerable: true,\n      configurable: true,\n      // 收集数据依赖\n      get() {\n        console.log(`获取了属性值 ${value}`);\n        Dependency.temp && dependency.addSub(Dependency.temp);\n        return value;\n      },\n      // 触发视图更新\n      set(newVal) {\n        console.log(`修改了属性值`);\n        value = newVal;\n        // 处理赋值是对象时的情况\n        Observer(newVal);\n        dependency.notify();\n      },\n    });\n  });\n}\n\n// 模板解析 —— 替换DOM内容 把vue实例上的数据解析到页面上\n// 接收两个参数 1.vue实例挂载的元素<div id="app"> 2.vue实例\nfunction Complie(element, vm) {\n  vm.$el = document.querySelector(element);\n  // 使用文档碎片来临时存放DOM元素 减少DOM更新\n  const fragment = document.createDocumentFragment();\n  let child;\n  // 将页面里的子节点循环放入文档碎片\n  while ((child = vm.$el.firstChild)) {\n    fragment.appendChild(child);\n  }\n  fragment_compile(fragment);\n  // 替换fragment里文本节点的内容\n  function fragment_compile(node) {\n    // 使用正则表达式去匹配并替换节点里的{{}}\n    const pattern = /\\{\\{\\s*(\\S+)\\s*\\}\\}/;\n    if (node.nodeType === 3) {\n      // 提前保存文本内容 否则文本在被替换一次后 后续的操作都会不生效\n      // 名称: {{name}}  => 名称：martin 如果不保存后续修改name会匹配不到{{name}} 因为已经被替换\n      const texts = node.nodeValue;\n      // 获取正则表达式匹配文本字符串获得的所有结果\n      const result_regex = pattern.exec(node.nodeValue);\n      if (result_regex) {\n        const arr = result_regex[1].split("."); // more.salary => [\'more\', \'salary\']\n        // 使用reduce归并获取属性对应的值 = vm.$data[\'more\'] => vm.$data[\'more\'][\'salary\']\n        const value = arr.reduce((total, current) => total[current], vm.$data);\n        node.nodeValue = texts.replace(pattern, value);\n        // 在节点值替换内容时 即模板解析的时候 添加订阅者\n        // 在替换文档碎片内容时告诉订阅者如何更新 即告诉Watcher如何更新自己\n        new Watcher(vm, result_regex[1], (newVal) => {\n          node.nodeValue = texts.replace(pattern, newVal);\n        });\n      }\n    }\n    // 替换绑定了v-model属性的input节点的内容\n    if (node.nodeType === 1 && node.nodeName === "INPUT") {\n      const attr = Array.from(node.attributes);\n      attr.forEach((item) => {\n        if (item.nodeName === "v-model") {\n          const value = item.nodeValue\n            .split(".")\n            .reduce((total, current) => total[current], vm.$data);\n          node.value = value;\n          new Watcher(vm, item.nodeValue, (newVal) => {\n            node.value = newVal;\n          });\n          node.addEventListener("input", (e) => {\n            // [\'more\', \'salary\']\n            const arr1 = item.nodeValue.split(".");\n            // [\'more\']\n            const arr2 = arr1.slice(0, arr1.length - 1);\n            // vm.$data.more\n            const final = arr2.reduce(\n              (total, current) => total[current],\n              vm.$data\n            );\n            // vm.$data.more[\'salary\'] = e.target.value\n            final[arr1[arr1.length - 1]] = e.target.value;\n          });\n        }\n      });\n    }\n    // 对子节点的所有子节点也进行替换内容操作\n    node.childNodes.forEach((child) => fragment_compile(child));\n  }\n  // 操作完成后将文档碎片添加到页面\n  // 此时已经能将vm的数据渲染到页面上 但还未实现数据变动的及时更新\n  vm.$el.appendChild(fragment);\n}\n\n//依赖 —— 实现发布-订阅模式 用于存放订阅者和通知订阅者更新\nclass Dependency {\n  constructor() {\n    this.subscribers = []; // 用于收集依赖data的订阅者信息\n  }\n  addSub(sub) {\n    this.subscribers.push(sub);\n  }\n  notify() {\n    this.subscribers.forEach((sub) => sub.update());\n  }\n}\n\n// 订阅者\nclass Watcher {\n  // 需要vue实例上的属性 以获取更新什么数据\n  constructor(vm, key, callback) {\n    this.vm = vm;\n    this.key = key;\n    this.callback = callback;\n    //临时属性 —— 触发getter 把订阅者实例存储到Dependency实例的subscribers里面\n    Dependency.temp = this;\n    key.split(".").reduce((total, current) => total[current], vm.$data);\n    Dependency.temp = null; // 防止订阅者多次加入到依赖实例数组里\n  }\n  update() {\n    const value = this.key\n      .split(".")\n      .reduce((total, current) => total[current], this.vm.$data);\n    this.callback(value);\n  }\n}\n')])])])])}),[],!1,null,null,null);e.default=r.exports}}]);